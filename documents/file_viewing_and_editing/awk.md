# Посібник з утиліти `awk`

`awk` (названа за першими літерами прізвищ її авторів — Alfred Aho, Peter Weinberger та Brian Kernighan) — це потужна мова програмування та утиліта командного рядка, призначена для сканування та обробки текстових даних. Вона читає вхідні дані (файл або потік) рядок за рядком і для кожного рядка може виконувати задані дії.

Сила `awk` полягає в її здатності розбивати кожен рядок на поля (колонки) і працювати з ними окремо.

### **Ключова концепція: Структура програми `awk`**

Основна логіка `awk` будується на парі **`'шаблон { дія }'`**.

```bash
awk '[шаблон] { дія }' [файл]
```

*   **`дія` (action)**: Код, написаний мовою `awk`, який виконується. Він завжди знаходиться у фігурних дужках `{}`. Якщо дія не вказана, виконується дія за замовчуванням — `{ print }` (друкувати весь рядок).
*   **`шаблон` (pattern)**: Умова, яка визначає, чи буде виконана `дія` для поточного рядка. Якщо шаблон не вказано, `дія` виконується для **кожного** рядка.

### **Поля та записи**

*   **Запис (Record)**: За замовчуванням, це один рядок тексту. `awk` обробляє один запис за раз.
*   **Поле (Field)**: За замовчуванням, це окремі слова або колонки в рядку, розділені пробілами або табуляцією.

`awk` автоматично присвоює змінним значення полів:
*   **`$0`**: Весь поточний рядок (запис).
*   **`$1`**: Перше поле.
*   **`$2`**: Друге поле, і так далі.
*   **`NF`**: **N**umber of **F**ields. Змінна, що містить кількість полів у поточному записі.
*   **`$NF`**: Значення останнього поля. Для доступу до передостаннього поля можна використовувати `$(NF-1)`, і так далі.
*   **`NR`**: **N**umber of **R**ecord. Номер поточного рядка (починаючи з 1).
*   **`FS`**: **F**ield **S**eparator. Символ-розділювач полів. За замовчуванням — пробіл. Його можна змінити.

### **Спеціальні шаблони: `BEGIN` та `END`**

*   **`BEGIN { дія }`**: Ця дія виконується **один раз** *до* того, як `awk` почне обробляти перший рядок файлу. Ідеально для ініціалізації змінних або друку заголовків.
*   **`END { дія }`**: Ця дія виконується **один раз** *після* того, як `awk` обробить останній рядок файлу. Ідеально для виведення підсумкових результатів (суми, середні значення).

---

### **Практичні приклади**

Для прикладів припустимо, що у нас є файл `data.txt`:
```
product_id category quantity price
101 electronics 10 150.00
102 books 50 15.50
103 electronics 5 499.99
104 kitchen 20 40.00
```

#### **1. Друк конкретних полів**

*   **Надрукувати перше та четверте поле кожного рядка:**
    ```bash
    awk '{ print $1, $4 }' data.txt
    ```

*   **Надрукувати останнє поле кожного рядка:**
    ```bash
    awk '{ print $NF }' data.txt
    ```

#### **2. Використання розділювача полів (`-F`)**

`awk` чудово підходить для обробки CSV-подібних файлів. Для цього використовується опція `-F`.

*   **Вивести імена користувачів та їхні оболонки з `/etc/passwd` (де розділювач — двокрапка):**
    ```bash
    awk -F':' '{ print $1, $7 }' /etc/passwd
    ```

#### **3. Фільтрація за шаблоном**

*   **Надрукувати рядки, що містять слово `electronics`:**
    *   Тут `/.../` — це регулярний вираз.
    ```bash
    awk '/electronics/' data.txt
    # Повна форма: awk '/electronics/ { print $0 }' data.txt
    ```

*   **Надрукувати рядки, де кількість (`$3`) більша за 15:**
    ```bash
    awk '$3 > 15' data.txt
    ```

*   **Надрукувати рядки, де категорія (`$2`) — це `books`:**
    ```bash
    awk '$2 == "books"' data.txt
    ```

*   **Надрукувати тільки 5-й рядок файлу:**
    ```bash
    awk 'NR == 5' data.txt
    ```

*   **Надрукувати діапазон рядків (з 4-го по 7-й):**
    ```bash
    awk 'NR > 3 && NR <= 7' data.txt
    ```

#### **4. Використання `BEGIN` та `END`**

*   **Порахувати загальну вартість товарів (кількість * ціна):**
    ```bash
    awk 'NR > 1 { total += $3 * $4 } END { print "Total value:", total }' data.txt
    # NR > 1 використовується, щоб пропустити заголовок
    ```

*   **Додати заголовок до виводу:**
    ```bash
    awk 'BEGIN { print "USER\tSHELL" } -F':' '{ print $1, $7 }' /etc/passwd
    ```

### **Написання скриптів `awk`**

Для складніших завдань логіку `awk` можна записувати у файл і виконувати за допомогою опції `-f`. Це робить код більш читабельним та зручним для повторного використання.

#### **Умови, цикли та функції**

`awk` підтримує стандартні конструкції мов програмування, такі як `if-else`, `while`, `for` та функції.

*   **Приклад з умовою `if` та оператором `~` (match):**
    *Знайдемо `https` сервіси, що працюють по `tcp`, і виведемо їх порт та опис.*
    ```bash
    awk '/^https/ { if($2 ~ /tcp/) { split($2, a, "/"); print "Port:", a[1], "-", $1 } }' /etc/services
    ```
    *Пояснення: `if($2 ~ /tcp/)` перевіряє, чи друге поле відповідає регулярному виразу `/tcp/`.*

#### **Використання файлів зі скриптами (`-f`)**

*   **Створимо файл `script.awk`:**
    ```awk
    # Це коментар в awk
    BEGIN {
        print "USER NAME            ID"
        print "-----------------------"
    }

    # Фільтруємо користувачів з ID > 500
    $3 > 500 {
        printf "%-20s %s\n", $1, $3
        count++
    }

    END {
        print "-----------------------"
        printf "Total users found: %d\n", count
    }
    ```

*   **Виконаємо скрипт:**
    ```bash
    awk -F: -f script.awk /etc/passwd
    ```

#### **5. Вбудовані функції та форматування**

*   **Надрукувати номер рядка та сам рядок:**
    ```bash
    awk '{ print NR, $0 }' data.txt
    ```

*   **Використовувати `printf` для форматованого виводу:**
    ```bash
    awk -F':' '{ printf("User: %-15s Shell: %s\n", $1, $7) }' /etc/passwd
    ```
    *   `%-15s` означає рядок, вирівняний по лівому краю, шириною 15 символів.

#### **6. Передача змінних з командного рядка (`-v`)**

Опція `-v` дозволяє передавати змінні з командного рядка в програму `awk`. Це корисно, коли вам потрібно використовувати зовнішні значення (наприклад, поточну дату, ім'я користувача) у ваших `awk` скриптах без їх жорсткого кодування.

*   **Приклад: Фільтрація логів за поточною датою.**
    Припустимо, ви хочете знайти всі записи в `/var/log/syslog`, які відповідають сьогоднішній даті.

    ```bash
    awk -v day=$(date +%d) -v month=$(date +%b) '$1 == month && $2 == day' /var/log/syslog
    ```
    *   **Пояснення:**
        *   `awk -v day=$(date +%d)`: Передає поточний день місяця (наприклад, "03") як змінну `day` в `awk`. Команда `date +%d` виводить день місяця як двозначне число.
        *   `awk -v month=$(date +%b)`: Передає скорочену назву поточного місяця (наприклад, "Nov") як змінну `month` в `awk`. Команда `date +%b` виводить скорочену назву місяця.
        *   `'$1 == month && $2 == day'`: Це шаблон `awk`. Він перевіряє, чи перше поле (`$1`) поточного рядка дорівнює значенню змінної `month` І чи друге поле (`$2`) дорівнює значенню змінної `day`. Якщо обидві умови істинні, `awk` друкує весь рядок (дія за замовчуванням `{ print $0 }`).
        *   `/var/log/syslog`: Вхідний файл, який `awk` буде обробляти.

*   **Приклад: Фільтрація логів за часом (записи старші за 1 годину).**
    Цей приклад демонструє, як можна фільтрувати записи логів, які були створені більше ніж годину тому, використовуючи порівняння рядків.

    ```bash
    awk -v d="$(date -d '1 hour ago' '+%b %d %H:%M:%S')" '$0 < d' /var/log/messages
    ```
    *   **Пояснення:**
        *   `date -d '1 hour ago' '+%b %d %H:%M:%S'`: Ця команда генерує рядок дати та часу, що відповідає одній годині тому, у форматі "Міс День Год:Хв:Сек" (наприклад, "Nov 03 10:30:00").
            *   `-d '1 hour ago'`: Вказує `date` обчислити час, що був 1 годину тому.
            *   `'+%b %d %H:%M:%S'`: Форматує вивід дати та часу.
                *   `%b`: Скорочена назва місяця (наприклад, Nov).
                *   `%d`: День місяця (01-31).
                *   `%H`: Година (00-23).
                *   `%M`: Хвилина (00-59).
                *   `%S`: Секунда (00-60).
        *   `awk -v d="..."`: Передає згенерований рядок дати та часу як змінну `d` в `awk`.
        *   `'$0 < d'`: Це шаблон `awk`. Він порівнює весь поточний рядок (`$0`) з рядком дати `d`. Якщо рядок логу лексикографічно "менший" (тобто хронологічно старіший) за `d`, то `awk` друкує цей рядок. Важливо, що це порівняння працює коректно, якщо формат дати в логах відповідає формату, згенерованому `date`.
        *   `/var/log/messages`: Вхідний файл логів, який `awk` буде обробляти.

### **Вбудовані рядкові функції (Built-in String Functions)**

`awk` надає багато вбудованих функцій для роботи з текстом. Ось деякі з найпоширеніших:

#### **1. `length([string])`**

Повертає кількість символів у рядку `string`. Якщо `string` не вказано, повертає довжину всього поточного рядка (`$0`).

*   **Приклад: Надрукувати рядки, довжина яких перевищує 30 символів.**
    ```bash
    awk 'length($0) > 30' data.txt
    ```

*   **Приклад: Вивести назву продукту та довжину його назви.**
    ```bash
    awk 'NR > 1 { print $1, length($1) }' data.txt
    ```

#### **2. `substr(string, start, [length])`**

Повертає частину рядка `string`, починаючи з позиції `start` і довжиною `length` символів. Якщо `length` не вказано, повертає залишок рядка.

*   **Приклад: Вивести перші 3 символи з назви кожної категорії.**
    ```bash
    awk 'NR > 1 { print substr($2, 1, 3) }' data.txt
    ```

#### **3. `index(string, substring)`**

Повертає позицію (індекс) першого входження `substring` у `string`. Якщо `substring` не знайдено, повертає 0.

*   **Приклад: Знайти рядки, де в назві категорії є літера `o`.**
    ```bash
    awk 'index($2, "o") > 0' data.txt
    ```

#### **4. `split(string, array, [separator])`**

Розбиває `string` на частини, використовуючи `separator` як розділювач, і зберігає результат у масив `array`. Повертає кількість елементів у масиві. Якщо `separator` не вказано, використовується `FS`.

*   **Приклад: Розбити поле `price` на доларову та центову частини.**
    Припустимо, у нас є файл `prices.txt`:
    ```
    item1 12.99
    item2 5.50
    ```
    ```bash
    awk '{ split($2, parts, "."); print "Dollars:", parts[1], "Cents:", parts[2] }' prices.txt
    ```

#### **5. `gsub(regexp, replacement, [target])`**

**G**lobal **Sub**stitution. Замінює **всі** входження регулярного виразу `regexp` на `replacement` у рядку `target`. Якщо `target` не вказано, заміна відбувається в усьому поточному рядку (`$0`).

*   **Приклад: Замінити "electronics" на "e-stuff" у всьому файлі.**
    ```bash
    awk '{ gsub(/electronics/, "e-stuff"); print }' data.txt
    ```

---

### **`awk` проти `grep` та `sed`**

*   **`grep`**: Найкраще підходить для простого пошуку рядків за шаблоном.
*   **`sed`**: Найкраще підходить для простої заміни тексту в рядках.
*   **`awk`**: Найкраще підходить, коли вам потрібно виконувати дії на основі полів (колонок): проводити обчислення, переставляти поля місцями, форматувати вивід. Це найпотужніший інструмент з трійки для складного аналізу тексту.

### **Приклад: форматування виводу `ls -l`**

За допомогою утиліти `awk` можна форматувати вивід команди `ls -l`.

**Завдання:** вивести список файлів з теки `/usr/lib/grub/i386-pc`, які мають розмір більше 200 байт і права на читання для власника, групи та інших.

```bash
sudo ls -l /usr/lib/grub/i386-pc | awk -v N=200 '
   NR==1 {
   print "______________________________________________"
   print "|             file name          |  size, Kb |"
   print "|____________________________________________|"
   next
   }
   $1 ~ /^-r..r..r../ && $5 > N {
   sizeKb = $5 / 1024
   printf "| %-30s |   %7.2f |\n", $9, sizeKb
   }
   END { print "______________________________________________" }
 '
```

**Пояснення:**

*   `sudo ls -l /usr/lib/grub/i386-pc`: виводимо список файлів у заданій теці.
*   `awk -v N=200`: передаємо в `awk` змінну `N` зі значенням 200.
*   `NR==1`: для першого рядка (`NR` - номер поточного рядка) виконуємо блок коду в фігурних дужках.
    *   `print "..."`: друкуємо заголовок таблиці.
    *   `next`: переходимо до наступного рядка, не виконуючи решту команд.
*   `$1 ~ /^-r..r..r../ && $5 > N`: це умова для відбору рядків.
    *   `$1 ~ /^-r..r..r../`: перше поле (права доступу) відповідає регулярному виразу. Це означає, що це файл (`-`), і він має права на читання (`r`) для власника, групи та інших.
    *   `$5 > N`: розмір файлу (5-е поле) більше `N` (200 байт).
*   `{ sizeKb = $5 / 1024; printf "| %-30s |   %7.2f |\n", $9, sizeKb }`: цей блок виконується, якщо умова вище істинна.
    *   `sizeKb = $5 / 1024`: обчислюємо розмір файлу в кілобайтах.
    *   `printf "| %-30s |   %7.2f |\n", $9, sizeKb`: форматуємо і друкуємо вивід.
        *   `%-30s`: рядкове поле шириною 30 символів, вирівняне по лівому краю (ім'я файлу, 9-е поле).
        *   `%7.2f`: числове поле з плаваючою комою шириною 7 символів з 2 знаками після коми (розмір в Кб).
*   `END { print "______________________________________________" }`: після обробки всіх рядків друкуємо нижню межу таблиці.

