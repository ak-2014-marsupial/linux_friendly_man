# Посібник з утиліти `awk`

`awk` (названа за першими літерами прізвищ її авторів — Alfred Aho, Peter Weinberger та Brian Kernighan) — це потужна мова програмування та утиліта командного рядка, призначена для сканування та обробки текстових даних. Вона читає вхідні дані (файл або потік) рядок за рядком і для кожного рядка може виконувати задані дії.

Сила `awk` полягає в її здатності розбивати кожен рядок на поля (колонки) і працювати з ними окремо.

### **Ключова концепція: Структура програми `awk`**

Основна логіка `awk` будується на парі **`'шаблон { дія }'`**.

```bash
awk '[шаблон] { дія }' [файл]
```

*   **`дія` (action)**: Код, написаний мовою `awk`, який виконується. Він завжди знаходиться у фігурних дужках `{}`. Якщо дія не вказана, виконується дія за замовчуванням — `{ print }` (друкувати весь рядок).
*   **`шаблон` (pattern)**: Умова, яка визначає, чи буде виконана `дія` для поточного рядка. Якщо шаблон не вказано, `дія` виконується для **кожного** рядка.

### **Поля та записи**

*   **Запис (Record)**: За замовчуванням, це один рядок тексту. `awk` обробляє один запис за раз.
*   **Поле (Field)**: За замовчуванням, це окремі слова або колонки в рядку, розділені пробілами або табуляцією.

`awk` автоматично присвоює змінним значення полів:
*   **`$0`**: Весь поточний рядок (запис).
*   **`$1`**: Перше поле.
*   **`$2`**: Друге поле, і так далі.
*   **`NF`**: **N**umber of **F**ields. Змінна, що містить кількість полів у поточному записі.
*   **`$NF`**: Значення останнього поля.
*   **`NR`**: **N**umber of **R**ecord. Номер поточного рядка (починаючи з 1).
*   **`FS`**: **F**ield **S**eparator. Символ-розділювач полів. За замовчуванням — пробіл. Його можна змінити.

### **Спеціальні шаблони: `BEGIN` та `END`**

*   **`BEGIN { дія }`**: Ця дія виконується **один раз** *до* того, як `awk` почне обробляти перший рядок файлу. Ідеально для ініціалізації змінних або друку заголовків.
*   **`END { дія }`**: Ця дія виконується **один раз** *після* того, як `awk` обробить останній рядок файлу. Ідеально для виведення підсумкових результатів (суми, середні значення).

---

### **Практичні приклади**

Для прикладів припустимо, що у нас є файл `data.txt`:
```
product_id category quantity price
101 electronics 10 150.00
102 books 50 15.50
103 electronics 5 499.99
104 kitchen 20 40.00
```

#### **1. Друк конкретних полів**

*   **Надрукувати перше та четверте поле кожного рядка:**
    ```bash
    awk '{ print $1, $4 }' data.txt
    ```

*   **Надрукувати останнє поле кожного рядка:**
    ```bash
    awk '{ print $NF }' data.txt
    ```

#### **2. Використання розділювача полів (`-F`)**

`awk` чудово підходить для обробки CSV-подібних файлів. Для цього використовується опція `-F`.

*   **Вивести імена користувачів та їхні оболонки з `/etc/passwd` (де розділювач — двокрапка):**
    ```bash
    awk -F':' '{ print $1, $7 }' /etc/passwd
    ```

#### **3. Фільтрація за шаблоном**

*   **Надрукувати рядки, що містять слово `electronics`:**
    *   Тут `/.../` — це регулярний вираз.
    ```bash
    awk '/electronics/' data.txt
    # Повна форма: awk '/electronics/ { print $0 }' data.txt
    ```

*   **Надрукувати рядки, де кількість (`$3`) більша за 15:**
    ```bash
    awk '$3 > 15' data.txt
    ```

*   **Надрукувати рядки, де категорія (`$2`) — це `books`:**
    ```bash
    awk '$2 == "books"' data.txt
    ```

#### **4. Використання `BEGIN` та `END`**

*   **Порахувати загальну вартість товарів (кількість * ціна):**
    ```bash
    awk 'NR > 1 { total += $3 * $4 } END { print "Total value:", total }' data.txt
    # NR > 1 використовується, щоб пропустити заголовок
    ```

*   **Додати заголовок до виводу:**
    ```bash
    awk 'BEGIN { print "USER\tSHELL" } -F':' '{ print $1, $7 }' /etc/passwd
    ```

#### **5. Вбудовані функції та форматування**

*   **Надрукувати номер рядка та сам рядок:**
    ```bash
    awk '{ print NR, $0 }' data.txt
    ```

*   **Використовувати `printf` для форматованого виводу:**
    ```bash
    awk -F':' '{ printf("User: %-15s Shell: %s\n", $1, $7) }' /etc/passwd
    ```
    *   `%-15s` означає рядок, вирівняний по лівому краю, шириною 15 символів.

### **Вбудовані рядкові функції (Built-in String Functions)**

`awk` надає багато вбудованих функцій для роботи з текстом. Ось деякі з найпоширеніших:

#### **1. `length([string])`**

Повертає кількість символів у рядку `string`. Якщо `string` не вказано, повертає довжину всього поточного рядка (`$0`).

*   **Приклад: Надрукувати рядки, довжина яких перевищує 30 символів.**
    ```bash
    awk 'length($0) > 30' data.txt
    ```

*   **Приклад: Вивести назву продукту та довжину його назви.**
    ```bash
    awk 'NR > 1 { print $1, length($1) }' data.txt
    ```

#### **2. `substr(string, start, [length])`**

Повертає частину рядка `string`, починаючи з позиції `start` і довжиною `length` символів. Якщо `length` не вказано, повертає залишок рядка.

*   **Приклад: Вивести перші 3 символи з назви кожної категорії.**
    ```bash
    awk 'NR > 1 { print substr($2, 1, 3) }' data.txt
    ```

#### **3. `index(string, substring)`**

Повертає позицію (індекс) першого входження `substring` у `string`. Якщо `substring` не знайдено, повертає 0.

*   **Приклад: Знайти рядки, де в назві категорії є літера `o`.**
    ```bash
    awk 'index($2, "o") > 0' data.txt
    ```

#### **4. `split(string, array, [separator])`**

Розбиває `string` на частини, використовуючи `separator` як розділювач, і зберігає результат у масив `array`. Повертає кількість елементів у масиві. Якщо `separator` не вказано, використовується `FS`.

*   **Приклад: Розбити поле `price` на доларову та центову частини.**
    Припустимо, у нас є файл `prices.txt`:
    ```
    item1 12.99
    item2 5.50
    ```
    ```bash
    awk '{ split($2, parts, "."); print "Dollars:", parts[1], "Cents:", parts[2] }' prices.txt
    ```

#### **5. `gsub(regexp, replacement, [target])`**

**G**lobal **Sub**stitution. Замінює **всі** входження регулярного виразу `regexp` на `replacement` у рядку `target`. Якщо `target` не вказано, заміна відбувається в усьому поточному рядку (`$0`).

*   **Приклад: Замінити "electronics" на "e-stuff" у всьому файлі.**
    ```bash
    awk '{ gsub(/electronics/, "e-stuff"); print }' data.txt
    ```

---

### **`awk` проти `grep` та `sed`**

*   **`grep`**: Найкраще підходить для простого пошуку рядків за шаблоном.
*   **`sed`**: Найкраще підходить для простої заміни тексту в рядках.
*   **`awk`**: Найкраще підходить, коли вам потрібно виконувати дії на основі полів (колонок): проводити обчислення, переставляти поля місцями, форматувати вивід. Це найпотужніший інструмент з трійки для складного аналізу тексту.
