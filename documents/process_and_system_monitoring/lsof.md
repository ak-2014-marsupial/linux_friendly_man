Утиліта `lsof` (list open files) — це потужний інструмент командного рядка для виведення інформації про файли, які відкриті різними процесами в системі. "Файлами" в Unix-подібних системах вважається майже все: звичайні файли, директорії, мережеві сокети, канали (pipes) тощо.

#### **Базовий синтаксис**

```bash
lsof [ключі] [умови]
```

*   **`[ключі]`**: Параметри, що змінюють поведінку та формат виводу.
*   **`[умови]`**: Фільтри для вибору конкретних процесів, користувачів або файлів.

---

### **Основні колонки у виводі `lsof`**

| Колонка | Пояснення |
| :--- | :--- |
| **`COMMAND`** | Назва команди процесу, що відкрив файл. |
| **`PID`** | Ідентифікатор процесу (Process ID). |
| **`USER`** | Користувач, від імені якого запущено процес. |
| **`FD`** | Файловий дескриптор. Це номер, який процес використовує для доступу до файлу. |
| **`TYPE`** | Тип файлу (наприклад, `REG` для звичайного файлу, `DIR` для директорії, `IPv4` для сокета). |
| **`DEVICE`** | Ідентифікатор пристрою, на якому знаходиться файл. |
| **`SIZE/OFF`** | Розмір файлу або зміщення (offset) всередині нього. |
| **`NODE`** | Номер inode файлу. |
| **`NAME`** | Повний шлях до файлу або опис мережевого з'єднання. |

### **Значення файлових дескрипторів (FD)**

*   **`cwd`**: Поточна робоча директорія процесу (current working directory).
*   **`rtd`**: Коренева директорія процесу (root directory).
*   **`txt`**: Текстовий файл програми (виконуваний код).
*   **`mem`**: Файл, завантажений у пам'ять (memory-mapped file).
*   **`0, 1, 2`**: Стандартні потоки (0 - stdin, 1 - stdout, 2 - stderr).
*   **`NUMBERu`**: (наприклад, `3u`) — звичайний файловий дескриптор з номером 3, відкритий для читання та запису (`u`).
*   **`NUMBERr`**: (наприклад, `4r`) — дескриптор, відкритий тільки для читання (`r`).
*   **`NUMBERw`**: (наприклад, `5w`) — дескриптор, відкритий тільки для запису (`w`).

---

### **Основні ключі та умови**

| Ключ | Опис | Приклад |
| :--- | :--- | :--- |
| **`-i [family][@host][:port]`** | **Фільтрація за мережевими з'єднаннями.** Дозволяє відібрати процеси за типом протоколу (TCP, UDP), IP-адресою або портом. | `lsof -i :22` (хто слухає SSH-порт), `lsof -i TCP` (всі TCP-з'єднання), `lsof -i @192.168.1.5` (з'єднання з цією IP-адресою). |
| **`-p PID`** | **Фільтрація за ID процесу.** Показує всі файли, відкриті процесом із вказаним `PID`. Можна вказати кілька PID через кому: `-p 123,456`. | `lsof -p 1` (що відкрито процесом `init`/`systemd`). |
| **`-u username`** | **Фільтрація за іменем користувача.** Показує файли, відкриті процесами, що належать вказаному користувачеві. | `lsof -u www-data` (що відкрито веб-сервером). |
| **`-c command`** | **Фільтрація за назвою команди.** Показує файли, відкриті процесами, назва яких починається з `command`. | `lsof -c apache2` (що відкрито процесами Apache). |
| **`+D /directory`** | **Пошук у директорії (рекурсивно).** Показує всі файли, відкриті всередині вказаної директорії та її піддиректорій. Це повільна операція. | `lsof +D /var/log` (які процеси працюють з лог-файлами). |
| **`-d FD`** | **Фільтрація за файловим дескриптором.** Дозволяє знайти файли за конкретним номером дескриптора (наприклад, `1` для stdout) або діапазоном (`0-2`). | `lsof -d 0-2` (показати стандартні потоки для всіх процесів). |
| **`+L [count]`** | **Пошук файлів без посилань (видалених).** Показує файли, які були видалені, але все ще утримуються відкритими процесами. `count` — кількість посилань (link count), зазвичай `1` або `0`. | `sudo lsof +L1` (знайти видалені файли, що займають місце). |
| **`/path/to/file`** | **Пошук за повним шляхом до файлу.** Показує, який процес (або процеси) утримує вказаний файл відкритим. | `lsof /var/log/syslog` (хто зараз працює з системним логом). |

---

### **Приклади використання**

1.  **Показати всі відкриті файли в системі (може бути дуже багато виводу):**
    ```bash
    sudo lsof
    ```

2.  **Дізнатися, який процес слухає порт 80 (HTTP):**
    ```bash
    sudo lsof -i :80
    ```

3.  **Показати всі мережеві з'єднання для користувача `www-data`:**
    ```bash
    sudo lsof -u www-data -i
    ```

4.  **Показати всі відкриті файли для процесу з PID 1 (systemd):**
    ```bash
    sudo lsof -p 1
    ```

5.  **Знайти, який процес використовує файл `/var/log/auth.log`:**
    ```bash
    sudo lsof /var/log/auth.log
    ```

6.  **Показати всі відкриті файли процесами, назва яких починається на `node`:**
    ```bash
    sudo lsof -c node
    ```

7.  **Показати всі TCP-з'єднання, встановлені з хостом `1.1.1.1`:**
    ```bash
    sudo lsof -i TCP@1.1.1.1
    ```

8.  **Показати всі файли, відкриті в директорії `/home/user/documents` та її піддиректоріях:**
    ```bash
    sudo lsof +D /home/user/documents
    ```

9.  **Показати всі відкриті файли, крім тих, що належать користувачу `root`:**
    ```bash
    sudo lsof -u ^root
    ```
    *(Символ `^` означає заперечення).*

10. **Скомбінувати умови: знайти, хто з користувачів, крім `root`, має відкриті IPv4 з'єднання:**
    ```bash
    sudo lsof -u ^root -i 4
    ```

---

### **Пошук видалених, але відкритих файлів**

Одна з найкорисніших можливостей `lsof` — це пошук файлів, які були видалені з файлової системи, але все ще утримуються активними процесами. Такі файли продовжують займати місце на диску, хоча ви їх не бачите за допомогою `ls`. Це часта причина проблеми "місце на диску закінчилося, хоча папки порожні".

**Сценарій:** Процес (наприклад, веб-сервер) пише логи у великий файл. Адміністратор видаляє цей файл (`rm /var/log/nginx/access.log`), але не перезапускає сервіс. Процес Nginx продовжує тримати файл відкритим і писати в нього дані. Місце на диску не звільняється, доки процес не буде перезапущено або поки він не закриє файловий дескриптор.

**Як знайти такі файли:**

Використовуйте `lsof` з фільтром за кількістю посилань (link count), яка для видалених файлів дорівнює 0.

```bash
sudo lsof +L1
```
або більш наочно:
```bash
sudo lsof | grep '(deleted)'
```

**Приклад виводу:**

```
COMMAND   PID      USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME
nginx    1234  www-data    2w   REG  253,1 1.5G          0 /var/log/nginx/access.log (deleted)
```

**Що робити з цим?**

1.  **Ідентифікувати процес:** У прикладі вище це `nginx` з PID `1234`.
2.  **Вирішити проблему:**
    *   **Найпростіший спосіб:** Перезапустити сервіс (`sudo systemctl restart nginx`). Це змусить процес закрити старий файловий дескриптор і створити новий файл логу. Місце на диску буде звільнено.
    *   **Без перезапуску (складніше):** Якщо перезапуск сервісу неможливий, можна спробувати змусити процес перевідкрити лог-файли (наприклад, через сигнал `USR1` для деяких сервісів) або обрізати файл через файлову систему `/proc`. Наприклад: `truncate -s 0 /proc/1234/fd/2`. **Це ризикована операція!**
