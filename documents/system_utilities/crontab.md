Утиліта `crontab` (cron table) — це стандартний планувальник завдань у Linux, який дозволяє автоматично виконувати команди або скрипти у визначений час.

Демон `cron`, що працює у фоні, щохвилини перевіряє файли `crontab` і запускає завдання, час яких настав.

#### **Базовий синтаксис**

```bash
crontab [опції] [файл]
```

--- 

### **Основні опції**

| Опція | Пояснення |
| :--- | :--- |
| **`-e`** | **Редагувати** поточний файл `crontab` для користувача. Це найчастіша команда. |
| **`-l`** | **Показати** вміст поточного файлу `crontab`. |
| **`-r`** | **Видалити** поточний файл `crontab`. **Увага: команда не питає підтвердження!** |

--- 

### **Формат запису завдання**

Кожен рядок у файлі `crontab` — це окреме завдання, яке має такий формат:

```
# ┌───────────── хвилина (0 - 59)
# │ ┌───────────── година (0 - 23)
# │ │ ┌───────────── день місяця (1 - 31)
# │ │ │ ┌───────────── місяць (1 - 12)
# │ │ │ │ ┌───────────── день тижня (0 - 6) (Неділя=0 або 7)
# │ │ │ │ │
# │ │ │ │ │
# * * * * *  /шлях/до/команди або скрипта
```

**Спеціальні символи:**
*   **`*`**: Будь-яке значення (наприклад, `*` у полі годин означає "щогодини").
*   **`,`**: Перелічення значень (наприклад, `1,15` у полі дня місяця означає "1-го та 15-го числа").
*   **`-`**: Діапазон значень (наприклад, `9-17` у полі годин означає "з 9 до 17 включно").
*   **`/`**: Крок (наприклад, `*/15` у полі хвилин означає "кожні 15 хвилин").

--- 

### **Приклади завдань**

1.  **Запускати скрипт кожні 5 хвилин:**
    ```crontab
    */5 * * * * /home/user/scripts/check_updates.sh
    ```

2.  **Робити резервну копію щодня о 3:30 ночі:**
    ```crontab
    30 3 * * * /home/user/scripts/backup.sh
    ```

3.  **Запускати команду щопонеділка о 9:00 ранку:**
    ```crontab
    0 9 * * 1 /usr/bin/python3 /home/user/scripts/send_report.py
    ```

4.  **Запускати скрипт 1-го числа кожного місяця о півночі:**
    ```crontab
    0 0 1 * * /home/user/scripts/monthly_cleanup.sh
    ```

5.  **Запускати команду в робочі години (з 9 до 18) у будні дні (з понеділка по п'ятницю):**
    ```crontab
    * 9-18 * * 1-5 /home/user/scripts/monitor_activity.sh
    ```

### **Як редагувати `crontab`**

1.  Відкрийте редактор:
    ```bash
    crontab -e
    ```
    *При першому запуску система може запропонувати вибрати текстовий редактор (наприклад, `nano`).*

2.  Додайте новий рядок із вашим завданням.

3.  Збережіть файл та вийдіть з редактора. `cron` автоматично застосує зміни.

### **Важливі зауваження**

*   **Шляхи до команд:** Завжди використовуйте повні шляхи до виконуваних файлів (наприклад, `/usr/bin/python3`), оскільки `cron` може не мати такого ж `PATH`, як ваш інтерактивний термінал.
*   **Перенаправлення виводу:** За замовчуванням `cron` надсилає будь-який вивід команди на системну пошту користувача. Щоб уникнути цього, перенаправляйте вивід:
    ```crontab
    # Перенаправити стандартний вивід і помилки у файл логу
    * * * * * /path/to/command > /home/user/cron.log 2>&1

    # Якщо вивід не потрібен
    * * * * * /path/to/command > /dev/null 2>&1
    ```
*   **Системний `crontab`:** Окрім користувацьких `crontab`, існує системний файл `/etc/crontab` та директорії `/etc/cron.d/`, `/etc/cron.hourly/` тощо. Вони використовуються для системних завдань.

---

### **Спеціальні скорочення (ключові слова)**

Замість п'яти полів часу, ви можете використовувати спеціальні рядки для зручності:

| Рядок | Еквівалент | Опис |
| :--- | :--- | :--- |
| **`@reboot`** | - | Виконується один раз після перезавантаження системи. |
| **`@yearly`** | `0 0 1 1 *` | Виконується раз на рік (опівночі 1 січня). |
| **`@annually`**| `0 0 1 1 *` | Те саме, що й `@yearly`. |
| **`@monthly`** | `0 0 1 * *` | Виконується раз на місяць (опівночі 1-го числа). |
| **`@weekly`** | `0 0 * * 0` | Виконується раз на тиждень (опівночі в неділю). |
| **`@daily`** | `0 0 * * *` | Виконується щодня опівночі. |
| **`@hourly`** | `0 * * * *` | Виконується на початку кожної години. |

**Приклад:**
```crontab
@reboot /home/user/scripts/on_startup.sh
@daily /home/user/scripts/daily_cleanup.sh
```

---

### **Змінні середовища (Environment Variables)**

Завдання `cron` виконуються в обмеженому середовищі, яке може відрізнятися від вашого звичайного терміналу.

*   **`PATH`**: Зазвичай, `PATH` для `cron` дуже короткий, наприклад `/usr/bin:/bin`. Саме тому рекомендується завжди використовувати повні шляхи до команд.
*   **Інші змінні**: `SHELL` (зазвичай `/bin/sh`), `LOGNAME`, `HOME`.

Ви можете визначити власні змінні середовища безпосередньо у файлі `crontab`:

```crontab
# Встановлюємо свій PATH
PATH=/usr/local/bin:/usr/bin:/bin

# Встановлюємо кастомну змінну
MY_VARIABLE=some_value

*/10 * * * * echo $MY_VARIABLE >> /tmp/test.log
```

---

### **Системний `crontab` та `/etc/cron.d`**

Файл `/etc/crontab` та файли в директорії `/etc/cron.d` мають розширений синтаксис, який вимагає вказати ім'я користувача, від імені якого буде виконана команда.

**Формат:**
```
# <хв> <год> <день> <міс> <день тижня> <користувач> <команда>
* * * * *  root    /path/to/system/script.sh
```
Це корисно для системних завдань, які мають виконуватися від імені певного користувача (часто `root`).

---

### **Поради для надійності та відладки**

1.  **Запобігання одночасному запуску (Locking):** Якщо ваш скрипт працює довго, а запускається часто, може виникнути ситуація, коли попередній екземпляр ще не завершився, а `cron` вже запускає новий. Для уникнення цього використовуйте утиліту `flock`:
    ```crontab
    # -n -- непро блокуючий режим: якщо лок зайнятий, команда не виконується
    */5 * * * * /usr/bin/flock -n /tmp/my_job.lock /path/to/long_script.sh
    ```

2.  **Відладка (Debugging):** Якщо завдання не працює, як очікувалося:
    *   **Перевірте системні логи:** `cron` записує свою активність у системні журнали. Використовуйте `grep CRON /var/log/syslog` (для Debian/Ubuntu) або `grep CRON /var/log/cron` (для CentOS/RHEL).
    *   **Перевірте пошту:** Якщо вивід не перенаправлено, `cron` надсилає його на локальну пошту користувача. Встановіть поштовий клієнт (наприклад, `mailutils`) і перевірте пошту командою `mail`.
    *   **Логуйте все:** Найпростіший спосіб — перенаправити весь вивід (`stdout` та `stderr`) у файл, як було показано раніше.

---

### **Забезпечення стабільної та "тихої" роботи**

Для критичних або часто виконуваних завдань важливо забезпечити їхню стабільність та мінімізувати небажаний "шум" (наприклад, постійні листи від cron).

#### **1. Стійкість завдань (Job Stability)**

*   **Контроль ресурсів (`nice`, `ionice`):** Щоб ваше завдання не впливало на продуктивність системи, особливо на завантажених серверах, запускайте його з нижчим пріоритетом.
    ```crontab
    # Запуск з найнижчим пріоритетом CPU (nice) та I/O (ionice)
    0 1 * * * nice -n 19 ionice -c 3 /path/to/resource-heavy-script.sh
    ```

*   **Обмеження часу виконання (`timeout`):** Якщо існує ризик, що скрипт може "зависнути", використовуйте команду `timeout`, щоб автоматично завершити його через певний час. Це запобігає накопиченню процесів, що "зависли".
    ```crontab
    # Дозволити скрипту працювати максимум 10 хвилин
    */15 * * * * timeout 10m /path/to/potentially-hanging-script.sh
    ```

*   **Написання надійних скриптів:** Найкраща стабільність досягається на рівні самого скрипта. Він повинен вміти коректно обробляти помилки: перевіряти наявність файлів, доступність мережі, перш ніж виконувати основну логіку.

#### **2. "Тиха" робота (Quiet Operation)**

За замовчуванням `cron` надсилає лист на системну пошту, якщо команда генерує будь-який вивід (`stdout` або `stderr`). Це може бути корисним для відладки, але часто призводить до спаму.

*   **Надсилання пошти лише при помилках:** Це найефективніший підхід. Налаштуйте ваш скрипт так, щоб він нічого не виводив при успішному виконанні, але генерував вивід в `stderr` у разі помилки.
    ```bash
    #!/bin/bash
    # Приклад скрипта, що "мовчить" при успіху
    
    # Виконуємо команду, її вивід приховуємо
    if ! command-that-might-fail >/dev/null 2>&1; then
      # Якщо команда завершилася з помилкою, пишемо в stderr
      echo "Помилка виконання о $(date)" >&2
      exit 1
    fi
    ```
    У такому разі `cron` надішле лист лише тоді, коли щось піде не так.

*   **Використання `logger` для централізованих логів:** Замість перенаправлення у файл, можна надсилати вивід у системний журнал `syslog` за допомогою утиліти `logger`. Це дозволяє тримати всі логи в одному місці та аналізувати їх стандартними засобами.
    ```crontab
    0 2 * * * /path/to/script.sh 2>&1 | /usr/bin/logger -t my-cron-script -p cron.info
    ```
    *   `-t my-cron-script` — додає тег для легкого пошуку.
    *   `-p cron.info` — вказує "facility" та рівень важливості.
    
    Потім ви можете переглядати ці логи командою `journalctl -t my-cron-script` або `grep my-cron-script /var/log/syslog`.
