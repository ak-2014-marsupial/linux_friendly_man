# Регулярні вирази

Регулярні вирази - це система синтаксичного розбору текстових фрагментів за шаблоном, який задає правило пошуку. Найпростіший варіант регулярного виразу - це звичайне слово, число і т.п.

Наприклад:

```bash
grep 'root' /etc/passwd
```

- знайде і виведе усі рядки, в яких зустрічається слово `root` (точніше вказана послідовність символів, вони можуть бути частиною і більшого слова). В даному випадку відбувається пошук наперед відомого слова. Якщо шуканих слів кілька - їх можна записати одним регулярним виразом:

```bash
grep -P 'root|ftp|mail' /etc/passwd
```

- шукатиме усі рядки, які містять хоча б одне із слів `root`, `ftp` або `mail`.

Часто виникає потреба знайти слова, які наперед невідомі, але які можна певним чином описати. Скажімо, воно має знаходитись на самому початку рядку, починатися на малу літеру "r" і містити лише латинські літери:

```bash
grep -oP '^r\w+' /etc/passwd
```

у виразі вище знак `^` - прив'язка слова до початку рядку, символ `r` відповідає сам за себе, знак `\` робить із звичайної літери метасимвол, або навпаки. В даному випадку із літери `w` було зроблено метасимвол, який означає клас символів слова (містить великі та малі літери латинського алфавіту, цифри і знак `_`). Сам по собі, `\w` збігається з будь-яким одним символом слова, але наше слово може мати більше однієї літери, тому наступний символ `+` означає 1 або більше повторень класу `\w`.

Існують різні класи символів, в залежності від реалізації рушія регулярних виразів (PCRE чи POSIX), вони можуть по-різному позначатися:

*   `\s` - пробіли, табуляції та інші недруковані симоли
*   `\d` - десяткові цифри
*   `\D` - усі симоли, окрім десяктових цифр
*   `[:xdigit:]` - клас шістнадцяткових цифр
*   `[:upper:]` - літери у верхньому регістрі (не тільки латинські) і т.п.

Наприклад, знайти шістнадцятковий код кольору, який може виглядати так `#3F5A90`, або так `#F90`:

```bash
grep -E '#([[:xdigit:]]{6}|[[:xdigit:]]{3})' /some/file
```

В цьому виразі символ `#` відповідає сам за себе, круглі дужки необхідні для обмеження дії оператора `|` (або), `[:xdigit:]` - бо код кольору має шістнадцяткові значення, фігурні дужки задають кількість повторення попереднього шаблону (або символу). Іншими словами, цей вираз задає шаблон для знаходження усіх рядків, які містить знак `#` і після якого одразу ідуть 3 або 6 шістнадцяткових цифри.

Іноді напередвизначених класів не достатньо, тому в регулярних виразах є можливість визначати свої класи в квадратних дужках, наприклад `[aX12]` - клас символів, який може приймати один із чотирьох зазначених символи. Зверніть увагу не те, що регістр має значення, принаймні за замовчуванням, якщо не діють певні модифікатори.

Якщо символи в таблиці символів ідуть підряд, їх можна вказувати через дефіс (знак мінус), наприклад `[a-fA-F0-9]`.

Якщо треба оголосити клас, який може збігатися з будь-яким символом окрім заданих, для цього на початку класу вказується символ `^`, наприклад `[^:;\s]` - усе крім пробільних символів, двокрапки і крапки з комою.

Ще кілька прикладів із урахуванням вище наведеного:

```bash
grep -oP '#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})\b'
```

- схожий на попередній приклад, але записане в PCRE-стилі, а також додане `\b` - уявний символ, який вказує на кінець слова.

```bash
grep -oP '</?[^>]+>' /some/file.html
```

- знайти усі теги, включно із додатковими опціями. В цьому виразі знаки `<` та `>` відповідають самі за себе, `/?` вказує на те, що знак `/` може зустрітися (закриваючий тег), а може і не зустрітися, клас символів `[^>]` означає будь-який символ, окрім закриваючої кутової дужки, `+` як і раніше означає одне або більше повторень.

Цей регулярний вираз може бути більш цікавим у поєднанні з утилітою `sed`, скажімо, ми хочемо вивести вміст html-сторінки без тегів:

```bash
sed -r 's|</?[^>]+>||g' some.html
```

- прибере теги (але якщо вони описані в межах рядка)

Аналогічний синтаксис є і у редакторі `vim` (як для просто пошуку, так і для пошуку із заміною):

```vim
:1,%s#</\?\_[^>]\+>##gc
```

- вже схоже на якусь дичину, чи не так? :) Хоч `vim` - це окрема історія, тут все відносно просто:
    *   `:` - початок команди
    *   `1,%` - задіяти команду від першого до останнього рядка файлу
    *   `s` - substitude - пошук із заміною (як в `sed`)
    *   `# що шукаємо # на що замінюємо #` - знак `#` був обраний в якості роздільника, бо він не повторюється із символами даного конкретного регулярного виразу.
    *   Усе решта майже те саме, окрім того, що знаки `?` та `+` необхідно в `vim` додатково екранувати (додавати знак `\` попереду).
    *   Екранований знак `_` дозволяє класу символів `[^>]` збігатися також і з переносом на новий рядок (іншими словами, дозволяє шукати результати, які можуть розтягуватися на кілька рядків).
    *   Модифікатор `g` - шукати усі результати в межах рядку, а не лише перший;
    *   модифікатор `с` - очікувати підтвердження на заміну кожної із знахідок.

---

# Круглі дужки

В регулярних виразах круглі дужки, окрім групування, можуть виконувати ряд додаткових дій:

## 1. Запам'ятовування фрагментів збігу

Круглі дужки роблять це за замовчуванням. Цим механізмом часто користуються в реалізації рушіїв регулярних виразів різних мов програмування, а також певних утилітах.

Візьмемо утиліту `sed` для прикладу, задача - привести формат дат із `03/14/2025` в `14-03-25`:

```bash
echo "03/14/2025" | sed -r 's|\b([0-9]{2})/([0-9]{2})/20([0-9]{2})\b|\2-\1-\3|'
```

У прикладі вище, дані надходять в утиліту `sed` на її `STDIN`, групи дужок нумеруються послідовно, починаючи із 1.

Круглі дужки можуть зустрітися усередині інших круглих дужок, щоб не було плутанини із нумерацією, групи дужок рахуються по їх відкриваючим дужкам:

```bash
some_text='phone number: 380991232323'
if [[ "$some_text" =~ \+?(38(0[0-9]{2})[0-9]{7})([^0-9]|$) ]]; then echo -e "Operator: ${BASH_REMATCH[2]}\nNumber: ${BASH_REMATCH[1]}"; fi
```

```
Operator: 099
Number: 380991232323
```

Вище використано вбудовану в оболонку `bash` реалізацію регулярних виразів. Оператор `=~` в межах подвійних квадратних дужок `[[ ... ]]` застосовує шаблон (правий аргумент) до вхідних даних (лівий аргумент). Якщо регулярний вираз мав збіг, результатом операції буде істина, і умова виконається. Фрагменти збігу шаблону зберігаються в спеціальній змінній - `BASH_REMATCH`.

Можна відмінити запам'ятовування фрагменту збігу взятого в круглі дужки у певних реалізаціях регулярних виразів. Наприклад, в `Python` та `PCRE` це можна зробити, позначивши дужки наступним чином `(?: )`. В наступному прикладі перші дужки не запам'ятовують збіг, тому нумерація починається із наступних дужок:

```python
import re
number = '00121597'
res = re.search("^(?:00|\+)(\d{2})(\d+)$", number)
print (res.group(1) + "-" + res.group(2))
# 12-1597
```

До фрагменту, який мав збіг можна звернутися в іншому місці цього ж регулярного виразу, скажімо, ми хочемо знайти усі слова, що починаються і закінчуються на одну і ту саму літеру:

```bash
echo 'sdf abca asd' | grep -oP '\b(\w)\w*\1\b'
# abca
```

Якщо дужок багато, або ми хочемо зробити регулярний вираз більш зрозумілим, дужкам можна давати назви (в різних варіаціях регулярних виразів синтаксис може відрізнятися):

```python
import re
date = '05-13-2025'
res = re.search("^(?P<month>\d{2})-(?P<day>\d{2})-(?P<year>\d{2}|\d{4})$", date)
print (f"Year:\t{res.group('year')}\nMonth:\t{res.group('month')}\nDay:\t{res.group('day')}")
# Year:    2025
# Month:   05
# Day:     13
```

## 2. Пошук вперед / назад

Регулярні вирази дають можливість "прив'язати" збіги шаблону до конкретних місць в рядку. В прикладах вище ми вже вживали подібні прив'язки: `^` - до початку рядку, `$` -  до кінця рядку, `\b` - до межі слова. Ці метасимовли вказують на певне місце в рядку, але не займають при цьому жодного місця в ньому (їх ще називають якорями). Але що якщо ми хочемо розглянути збіги із шаблоном, який зустрічається після конкретного слова в рядку?

Наприклад, ми хочемо записати суму, що вказана після слова "Total":

```bash
cat <<EOF > text
item1: 10.1$
item3: 15.0$
---
Total: 15.1$
EOF

grep -oP 'Total:\s\d+([.,]\d{1,2})?\$' text
# Total: 15.1$
```

У прикладі вище ми знайшли що хотіли, але до результату пошуку увійшли також самі прив'язки (слово "Total" і знак "$"). Тут можна використати дужки, що збережуть саме число, але не усі утиліти дозволяють працювати із результатами захоплення після закінчення роботи утиліти. В даному випадку, ці прив'язки можна оформити у вигляді спеціальних прив'язок (по типу `^`, яке означає початок рядку, але до результатів збігу не входить):

```bash
grep -oP '(?<=Total:\s)\d+([.,]\d{1,2})?(?=\$)' text
# 15.1
```

У прикладі вище, `(?<= ... )` - це пошук назад (lookbehind), а `(?= ... )` - пошук вперед (lookahead). Ці оператори "озираються" відносно поточного місця (курсору), регулярний вираз матиме збіг лише за умови, якщо усі такі пошуки повернуть істину. Особливістю `lookbehind` є те, що він обов'язково має бути сталої довжини, тобто у виразі пошуку назад не має бути квантифікаторів (множників) по типу `{1,5}`, `?`, `*`, `+` тощо.

Пошук вперед та назад може бути і негативний (повертати істину, якщо умова не виконається). Позначаються вони так:
*   `(?! ... )` - негативний пошук вперед
*   `(?<! ... )` - негативний пошук назад

Скажімо, ми хочемо знайти усі міста, які починаються на латинську літеру 'B', але результат пошуку не має включати `Bandung`, `Barcelona` та `Bursa`:

```bash
echo 'Boryspil' | grep -P '^(?!Bandung|Barcelona|Bursa)B[\w\s]+$'
# Boryspil
```

---

# Валідація

Регулярні вирази досить часто використовують для перевірки відповідності рядка певним критеріям. Чим точніше описаний шаблон, тим більше критеріїв для перевірки він в собі містить.

Скажімо, необхідно перевірити, чи заданий рядок є IPv4 адресою. Наступний шаблон може допомогти з цією задачею:

```regex
^((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])$
```

Чому він такий складний? Справа в тому, що в регулярному виразі не можна задати діапазон чисел у вигляді `0-255`, можна лише описати як можуть виглядати значення в октетах. Якщо проаналізувати наведений регулярний вираз, то його основою є опис можливих значень в октеті:

```regex
25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9]
```

Тут зібрано 5 можливих варіанти:

*   `25[0-5]` - числа від 250 до 255
*   `2[0-4][0-9]` - числа від 200 до 249
*   `1[0-9]{2}`, або `1[0-9][0-9]` - числа від 100 до 199
*   `[1-9][0-9]` - числа від 10 до 99
*   `[0-9]` - числа від 0 до 9.

Два останніх випадки можна було б об'єднати в один: `[0-9][0-9]?`, але тоді були б збіги із значеннями `05`, `09` і т.п.

Як видно, такий регулярний вираз описує усі можливі варіації значень IPv4 адреси. Але разом з тим, не завжди валідація буває потрібна. Скажімо, ми хочемо знайти усі фрагменти в тексті, які просто схожі на IPv4 адресу. Опис такого шаблону буде значно простішим: кожен октет може мати від однієї до трьох цифр, самі октети розділені між собою крапками.

```bash
grep -oP '\b(\d{1,3}\.){3}\d{1,3}\b' some.file
```

Вираз вище допоможе знайти IPv4 адреси, хоча з цим шаблоном будуть збігатися і такі результати: `800.500.800.1`, `000.00.0.300` і т.п. Це не робить згаданий шаблон "поганим", бо із знайденої множини результатів, може бути значно простіше очима відкинути явно зайві результати (і це може бути виправдано, якщо результат отримано швидко).

## Пошук вперед для перевірки кількох умов

У випадку якщо рядок тексту має відповідати одночасно кільком умовам, може допомогти пошук веред. Скажімо, ми хочемо перевірити пароль на відповідність таким критеріям:

*   має не менше 8 символів
*   має хоча б одну маленьку літеру
*   має хоча б одну велику літеру
*   має хоча б одну цифру
*   має 2 або більше спеціальні символи

Ідея в тому, щоб перебуваючи на початку рядку зробити 5 пошуків вперед і, якщо усі вони будуть успішні, регулярний вираз має збігтися із цим паролем (`.*`).

Кожну із цих умов можна описати окремими виразоми:

*   `^.{8,}$`
*   `.*[a-z]`
*   `.*[A-Z]`
*   `.*[0-9]`
*   `(.*[\W_]){2}`

Відповідно, увесь регулярний вираз зібраний до купи:

```regex
^(?=.{8,}$)(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=(.*[\W_]){2}).*
```

Для поліпшення швидкодії, можна записати цей вираз із використанням взаємовиключних класів, а також замінити `.*` на одну із умов:

```regex
^(?=[^a-z]*[a-z])(?=[^A-Z]*[A-Z])(?=\D*\d)(?=([a-zA-Z0-9]*[\W_]){2}).{8,}$
```

```bash
# This command will produce no output as the password 'abcA1_ba' has only one special character
echo 'abcA1_ba' | grep -P '^(?=[^a-z]*[a-z])(?=[^A-Z]*[A-Z])(?=\D*\d)(?=([a-zA-Z0-9]*[\W_]){2}).{8,}$'

# This command will produce output as the password 'abcA1_+a' matches all criteria
echo 'abcA1_+a' | grep -P '^(?=[^a-z]*[a-z])(?=[^A-Z]*[A-Z])(?=\D*\d)(?=([a-zA-Z0-9]*[\W_]){2}).{8,}$'
# abcA1_+a
```

---

# Квантифікатори

Квантифікатор вказує на кількість повторів попереднього шаблону, яким може бути або попередній символ, або цілий вираз узятий в круглі дужки.

Загалом, квантифікатори позначаються в фігурних дужках, в яких вказується мінімальна та максимальна кількість повторів:

`abc{2,5}`

може збігатися із `abcc`, `abcccc`, але не буде збігатися із `abc`, або `abccccccc` і т.д.

Якщо немає нижнього або верхнього обмежень, їх можна пропустити (не вказувати), але при цьому кому треба залишити: `{,5}` - кількість повторів від 0 до 5, або `{2,}` - від 2 повторів і більше. Якщо відома конкретна кількість повторів - це число задається саме: `{5}` - рівно 5 повторів.

Для розповсюджених випадків, таких як `{0,1}`, `{0,}`, `{1,}` є спеціальні скорочення, відповідно: `?`, `*`, `+`.

```regex
^(\+?38)?(0\d{2})\d{7}$
```

Приклад вище буде збігатися із `+380501232325`, `380772525123`, `0995551122`, і т.п. Зверніть увагу, що знак `+` необхідно екранувати (додавати попереду `\`) якщо ви хочете вживати його як знак `+`, а не метасимвол.

## Жадібний, лінивий або присвійний?

За лаштунками, квантифікатори працюють за певними алгоритмами. За замовчуванням, рушії регулярних виразів намагаються взяти максимум можливих збігів із шаблоном, після якого вказано квантифікатор. Це так званий "жадібний" алгоритм. Скажімо, є наступний регулярний вираз:

`^\d+15`

і є число `254815548915`.

Рушій регулярних виразів спробує по-максимуму "розкрити" `\d+`, в даному випадку воно матиме збіг із усім числом. Але далі в регулярному виразі ідуть дві цифри `1` і `5`, але `\d+` увібрало в себе увесь рядок і курсор вже знаходиться в кінці рядку. Регулярний вираз не має збігу.

Наступна дія в межах цього алгоритму - "віддати" одну цифру праворуч. Курсор тепер знаходиться тут: `25481554891<>5`. В кінці залишається `5`, воно не збігається із `15`. Регулярний вираз не має збігу.

Згідно алгоритму, треба віддати черговий символ із кінця, курсор тепер тут: `2548155489<>15`, `\d+` охоплює частину `2548155489`, цифри `15` збігаються із тими, що в шаблоні. Регулярний вираз в цілому має збіг.

Але можна піти іншим шляхом: не починати із максимального збігу, а навпаки - з мінімального і поступово його нарощувати. Розглянемо алгоритм роботи наступного виразу (зверніть увагу на знак `?` після квантифікатору):

`^\d+?15`

і візьмемо число із попереднього прикладу (`254815548915`).

`\d+` мусить мати збіг хоча б з однією цифрою, тому на першій ітерації `\d+` матиме збіг із цифрою `2`. Наступні дві цифри мають бути `15`, але маємо `54`. Збігу нема.

Нарощуємо збіг `\d+` на одну позицію, тепер воно збігається із `25`. Наступні дві цифри - `48`, збігу з `15` (що в регулярному виразі) - нема.

Поступово нарощуємо `\d+`, поки курсор не опиниться тут: `2548<>15548915`, `\d+` має збіг із `2548`, наступні цифри регулярного виразу збігаються із тими, що є в рядку. Регулярний вираз в цілому має збіг. Збігом є число `254815`.

Як видно, два регулярні вирази і різний результат, в залежності від обраного алгоритму роботи квантифікатора.

Ще кілька прикладів:

```bash
# Greedy match
echo '<p>Something here</p>' | grep -oP '</?.+>'
# Output: <p>Something here</p>
```
В цьому випадку `.+` згідно жадібного алгоритму схопив максимум, потім віддав один символ і весь регулярний вираз отримав збіг.

```bash
# Lazy match
echo '<p>Something here</p>' | grep -oP '</?.+?>'
# Output:
# <p>
# </p>
```
В цьому випадку згідно лінивого алгоритму регулярний вираз одразу мав збіг із `<p>`, потім курсор просувався по рядку, поки не дійшов до другого тегу і отримали ще один збіг.

Підсумовуючи, квантифікатори за замовчуванням працюють згідно жадібного алгоритму, якщо ми хочемо задіяти лінивий алгоритм - додаємо знак питання одразу після квантифікатора: `*?`, `+?`, `??`, `{n,m}?`, ...

Є ще одна модифікація жадібного алгоритму, в якому заборонено "віддавати" символи у разі, якщо вираз не має збігів. Це так званий "присвійний" (possessive) алгоритм. Для його застосування після квантифікатору вказують знак `+`: `*+`, `++`. Найчастіше такий алгоритм застосовують з метою оптимізації роботи регулярного виразу. Скажімо, маємо ситуацію взаємовиключних класів:

`^\d*AB$`

Якщо в кінці рядку не буде шуканих літер `AB`, то згідно жадібного алгоритму необхідно буде віддавати по одному символу від `\d+`, поки там залишаються цифри. Але вже наперед відомо, що скільки не віддавай цифр, літери там не з'являться і збігу не буде. Відповідно, щоб оптимізувати роботу регулярного виразу, можна одразу прибрати цикл "віддавання" і одразу сказати чи є збіг, чи його нема:

`^\d*+AB$`

Зазвичай, рушії регулярних виразів виконують оптимізацію виразів перед їх застосуванням і, по можливості, самі замінюють жадібні квантифікатори на присвійні.

---

# Базові елементи регулярного виразу

## Звичайні символи

Будь-який звичайний (не спеціальний) символ відповідає в регулярному виразі сам за себе. Звичайне слово - по суті теж частковий випадок регулярного виразу. Регістр символу має значення, тому вираз `xyz` в загальному випадку не буде збігатися із `XyZ`.

## Метасимволи (спеціальні символи)

`[ ] \ ^ $ . | & * + ( ) { }`

Метасимволи мають спеціальне призначення в регулярному виразі. Якщо необхідно відмінити цю їх особливість і вживати як звичайні символи - їх треба екранувати, тобто поставити перед ними символ `\`, або `\Q` та `\E` для групового екранування.

### . (крапка)

Будь-який символ, окрім символу нового рядку.

### Набір можливих символів `[ ]`

В шаблоні набір символів відповідає за збіг лише з **ОДНИМ** із вказаних в ньому символів. Наприклад, вираз `12[abc]50` буде збігатися із `12a50`, `12b50` та `12c50`, але не з `12ab50`, або `12abc50`.

Для зручності, послідовності символів можна задавати через дефіс, наприклад `[0-9]`, `[a-fA-F]`.

Щоб задати множину "усе окрім", можна задати знак `^` одразу після першої дужки: `[^0-9]` - означає будь-який символ, який не є цифрою.

### Іменовані класи (готові набори символів)

Для спрощення побудови регулярних виразів, типові набори символів отримали свої іменовані заготовки (класи). В залежності від реалізації рушія регулярних виразів (PCRE або POSIX) ці класи можуть відрізнятися.

#### POSIX класи

*   `[:alnum:]` - цифри (десяткові), літери великого та малого регістрів
*   `[:alpha:]` - літери великого та малого регістрів
*   `[:digit:]` - цифри
*   `[:lower:]` - літери малого регістру
*   `[:punct:]` - символи пунктуації (усі символи окрім цифр та літер)
*   `[:space:]` - пробільні символи
*   `[:upper:]` - літери великого регістру
*   `[:xdigit:]` - цифри шістнадцяткової системи числення
*   ...

#### PCRE (Perl compatible regular expression) класи

*   `\d` (або `[0-9]`) - цифри (десяткові)
*   `\w` (або `[a-zA-Z0-9_]`) - символи слова
*   `\s` (або `[ \t\n\r\f]`) - пробільні символи
*   `\D` (`[^0-9]`) - усе окрім цифр
*   `\W` - усе, окрім символів слова
*   `\S` - усе, окрім пробільних символів
*   ...

*У PCRE-класах є певні обмеження стосовно охоплення ними не латинських літер та цифр.*

### Прив'язка шаблону (Якорі)

*   `^` - метасимвол, який позначає початок рядку
*   `$` - позначення кінця рядку
*   `\b` - межа слова - місце в рядку, де символи класу `\w` змінюються символами класу `\W`, або навпаки
*   `\B` - позначка місця, в якому не повинно відбуватись переходу між класами `\w` та `\W`

**Наприклад:**
*   `^abc` - знайти послідовність `abc`, яка знаходиться на початку рядку.
*   `\babc\b` - шукати послідовність `abc` як окреме слово, а не як фрагмент більшого слова (буде збігатися із `abc`, а не `abcdef`).

### Повторення шаблону (Квантифікатори)

`{n}`, `{n,m}`, `{n,}`, `{,m}`, `*`, `+`, `?`

Щоб вказати, що певна частина шаблону має повторюватись певну кількість разів, використовують квантифікатори.

*   `{n}` - повторити попередній фрагмент шаблону `n` разів.
    *   `abc{5}` - 5 раз повторити символ `c` (`abccccc`)
    *   `(abc){5}` - 5 раз повторити те, що містять в собі дужки (`abcabcabcabcabc`)
*   `{n,m}` - фрагмент шаблону може зустрічатись не менше `n` разів, але не більше `m` разів.
    *   `\b\d{1,3}\b` - буде шукати число розміром від однієї до трьох цифр.
*   `{n,}` - не менше `n` повторень.
*   `{,m}` - не більше `m` повторень.

Певні повторення отримали свої окремі представлення:
*   `*` -> `{0,}` - шаблон може і не зустрітися, але якщо зустрінеться - то кількість його повторень не обмежена.
*   `+` -> `{1,}` - шаблон точно має бути, кількість його повторень - не обмежена.
*   `?` -> `{0,1}` - шаблон може зустрітися, а може і ні. Якщо і зустрінеться, то тільки в одному екземплярі.

### Групування фрагментів шаблону `( )`

Доволі часто складові частини регулярного виразу є необхідність групувати, наприклад щоб вказати рушію регулярних виразів область дії квантифікатора, або щоб запам'ятати збіг із вказаною частиною регулярного виразу.

*   **Для квантифікаторів:** `(\d{1,3}\.){3}\d{1,3}` - знайти результати, зовні схожі на IPv4 адреси (без валідації). Дужки в даному випадку вказують, що тричі має повторитися не фрагмент `\.`, а більша група: `\d{1,3}\.`.
*   **Для запам'ятовування (capturing):** В різних мовах програмування, а також спеціалізованих утилітах, можна вказати області регулярного виразу, які треба окремо запам'ятати в разі збігу. Позначаються ці області тими ж круглими дужками.
    *   `380(\d{2})\d{7}` - запам'ятати код оператора при знаходженні мобільного номера.

### Альтернатива (Логічне "АБО") `|`

Механізм регулярних виразів дозволяє розглядати одночасно кілька шаблонів-альтернатив. Для цього шаблони розділяються метасимволом `|`.

*   `abc|xyz` - шукатиме результати, що містять послідовність `abc`, або `xyz`.
*   Якщо потрібно обмежити область дії цього метасимвола, використовуються звичні круглі дужки: `ab(c|xy)z` - шукатиме послідовності `abcz` та `abxyz`.
