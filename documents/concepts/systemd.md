# Документація по Systemd

## Зміст

*   [Розділ 1. Еволюція Системи Ініціалізації Linux: Від SysVinit до systemd](#розділ-1-еволюція-системи-ініціалізації-linux-від-sysvinit-до-systemd)
*   [Розділ 2. Ключові Компоненти systemd та Їх Функціональність](#розділ-2-ключові-компоненти-systemd-та-їх-функціональність)
*   [Розділ 3. Управління Сервісами: Команда systemctl](#3-управління-сервісами-команда-systemctl)
*   [Розділ 4. Журналювання: Команда journalctl](#4-журналювання-команда-journalctl)
*   [Розділ 5. Анатомія Файлу Service Unit](#5-анатомія-файлу-service-unit)

---

# Розділ 1. Еволюція Системи Ініціалізації Linux: Від SysVinit до systemd

Systemd є не просто менеджером сервісів, це фундаментальна зміна в архітектурі Linux. Щоб повністю зрозуміти його важливість, необхідно подивитися на те, як система працювала раніше.

## 1.1 Історичний Контекст: Ера SysVinit та Його Обмеження (До 2010)

Протягом десятиліть домінувала система ініціалізації SysVinit (System V init).

**Як це працювало:**

*   **Головний процес (PID 1):** SysVinit був процесом з ідентифікатором PID 1, який запускався ядром першим.
*   **Сценарії Shell:** Для запуску сервісів використовувалися послідовні shell-скрипти (зазвичай bash), розташовані в каталогах на кшталт `/etc/init.d/`.
*   **Рівні запуску (Runlevels):** Система використовувала числові рівні запуску (runlevels), наприклад, `runlevel 3` для багатокористувацького режиму без GUI, `runlevel 5` для графічного режиму. Ці рівні визначали, які скрипти мають бути виконані.

### Проблеми та Обмеження SysVinit

| Проблема | Пояснення |
| :--- | :--- |
| **Послідовний запуск (Sequence Startup)** | Скрипти виконувалися один за одним. Якщо один скрипт зависав або був повільним (наприклад, перевірка мережі), вся система чекала. **Результат:** Дуже повільний час завантаження. |
| **"Залежності" через символічні посилання** | Залежності між сервісами керувалися заплутаною системою нумерованих символічних посилань (напр. `S20myservice`), що було складно підтримувати. |
| **Відсутність відстеження процесів** | SysVinit не міг надійно відстежувати всі дочірні процеси сервісу. Якщо головний процес помирав, дочірні процеси могли залишитися "зомбі" або просто без контролю. |
| **Складність та схильність до помилок** | Скрипти були написані мовою Shell, що вимагало знання складних інструкцій, обробки аргументів (`case "$1"`) та ручного управління PID-файлами. Будь-яка помилка в логіці могла призвести до збою. ([Див. приклад](#6-додаток-приклад-init-скрипта-в-sysvinit)) |
| **Відсутність стандартизації** | Хоча існували шаблони, розробники часто писали власні реалізації логіки запуску/зупинки, що ускладнювало підтримку та переносимість між дистрибутивами. |

### Але... З'явився systemd (2010)

Вимоги до сучасних систем (швидкий запуск, маштабованість, контейнеризація) зробили SysVinit застарілим. Двоє програмістів Red Hat, Леннарт Поеттерінг та Кей Сіверс, розробили systemd, щоб вирішити ці проблеми, беручи натхнення від таких систем, як `launchd` (macOS).

## 1.2 systemd: Нова Філософія та Архітектура

systemd — це не просто заміна SysVinit. Це цілий фреймворк для керування системою, який використовує сучасні функції ядра Linux.

### A. systemd як Головний Процес (PID 1)

*   **Призначення:** Як і SysVinit, systemd отримує PID 1. Він є коренем усіх процесів.
*   **Чому це важливо:** Якщо будь-який процес у системі втрачає свого батька (наприклад, батьківський процес завершується), ядро автоматично перепризначає systemd як нового батька. Це дозволяє systemd "усиновлювати" ці процеси та коректно їх завершувати (запобігаючи "зомбі-процесам"), на відміну від старих систем.
*   **Залежність від Linux:** systemd спочатку розроблявся виключно для Linux. Він активно використовує такі функції ядра, як `cgroups` (контрольні групи) для відстеження процесів та `fanotify` для моніторингу файлової системи.

### B. Концепція Юнітів (Unit Files)

Юніт — це базова одиниця конфігурації в systemd. Це простий текстовий файл (формату `.ini`), який декларативно описує, як керувати певним ресурсом (сервісом, точкою монтування, таймером) ([див. приклад](#5-анатомія-файлу-service-unit)).

**Розширене пояснення:**

*   **Декларативність:** Замість складного shell-скрипта (як у SysVinit), ви просто декларуєте бажаний стан: "запустити цей файл", "після мережі", "перезапускати при помилці".
*   **Розташування:**
    *   `/usr/lib/systemd/system/`: Юніти, які постачаються встановленими пакетами.
    *   `/etc/systemd/system/`: Юніти, створені або модифіковані системним адміністратором. Цей каталог має пріоритет.

### C. Активація на Вимогу (Activation)

Це ключова функція, що забезпечує швидкість і економію ресурсів, яка була недоступна у SysVinit.

*   **Активація через Сокет (`.socket`):**
    *   **Приклад:** Уявіть, що у вас є рідкісно використовуваний поштовий сервер (SMTP). Замість того, щоб тримати його постійно запущеним (як у SysVinit), systemd може слухати порт 25 (SMTP) через юніт `.socket`.
    *   Коли надходить перший мережевий запит на порт 25, тільки тоді systemd автоматично запускає відповідний `.service` юніт. Після обробки запиту сервіс може вимкнутися.
    *   **Перевага:** Економія RAM і процесорного часу для сервісів, які не потрібні 24/7.
*   **Активація через D-Bus:**
    *   Сервіс запускається, коли інша програма надсилає запит через системну шину D-Bus.

### D. Systemctl: Централізований Інтерфейс Управління

`systemctl` замінив безліч окремих команд (`service`, `chkconfig`, `initctl`) на єдиний інструмент.

**Розширене пояснення та Приклади:**

*   **Універсальність:** Незалежно від дистрибутива (Ubuntu, Fedora, Arch), команда для управління сервісом завжди однакова.
    *   **SysVinit:** Ви могли мати `service apache2 start` на Debian, але `/etc/init.d/httpd start` на Red Hat.
    *   **Systemd:** `systemctl start apache2.service` — працює скрізь.
*   **Перезавантаження конфігурації:**
    *   Ви внесли зміни до конфігураційного файлу вашого веб-сервера Nginx (`/etc/nginx/nginx.conf`).
    *   `systemctl reload nginx.service` — systemd надсилає сигнал Nginx'у, щоб він перечитав свій конфіг без зупинки роботи, зберігаючи активні з'єднання. Це набагато ефективніше, ніж повний `restart`.

### E. Journald: Інтегрована Система Журналювання

В SysVinit логи були розкидані по різних текстових файлах (`/var/log/messages`, `/var/log/syslog`, `/var/log/apache2/error.log`).

**Розширене пояснення:**

*   **Централізація та Бінарний Формат:** `journald` збирає всі логи в одному місці (зазвичай `/var/log/journal/`) у бінарному форматі. Це дозволяє логам бути структурованими, індексованими та дуже швидкими для пошуку.


**Щоб підкреслити переваги `journald`, ось порівняльна таблиця підходів до журналювання:**

| Характеристика | SysVinit (через syslog) | systemd (через journald) |
| :--- | :--- | :--- |
| **Логіка журналювання** | **Зовнішня.** Скрипт мав активно взаємодіяти з `syslog`, часто використовуючи команди на кшталт `logger`. | **Вбудована та автоматична.** `systemd` автоматично перехоплює весь стандартний вивід (stdout) та вивід помилок (stderr) сервісу. |
| **Формат логів** | Текстові файли, розкидані по системі (`/var/log/messages`, `/var/log/syslog` та ін.). | Централізований, структурований бінарний формат. |
| **Доступ до логів** | За допомогою текстових утиліт, як `grep`, `tail`, по різним файлам. | Через єдину потужну утиліту `journalctl` з можливістю фільтрації за сервісом, часом, пріоритетом. |
| **Що робить адміністратор** | Пише логіку журналювання всередині init-скрипта. | Нічого. Просто запускає сервіс. `systemd` робить все інше. |

*   **Потужний Фільтр `journalctl`:** На відміну від простого `grep` або `tail`, `journalctl` дозволяє швидко отримувати саме ту інформацію, яка вам потрібна, незалежно від того, коли вона була згенерована.
    *   **Приклад:** Якщо ви хочете побачити всі повідомлення, які генерував SSH-сервер за останні 30 хвилин:
        ```bash
        journalctl -u sshd --since "30 minutes ago"
        ```
    *   **Приклад:** Подивитися, що сталося в системі під час попереднього завантаження (дуже корисно для діагностики):
        ```bash
        journalctl -b -1
        ```

---



## 1.3 Суперечності та Критика systemd

Хоча systemd приніс беззаперечні переваги, його впровадження викликало одну з найбільших суперечок у спільноті відкритого коду.

*   **Порушення Принципу KISS (Keep It Simple, Stupid):** Критики стверджують, що systemd "робить занадто багато". Він об'єднав функції ініціалізації, логування, мережевого управління (через `systemd-networkd`), DNS-резолвінгу (через `systemd-resolved`) та інші. Вони вважають, що це створює надто велику, монолітну та складну систему.
*   **Залежність від Linux:** systemd покладається на Linux-специфічні функції (напр. `cgroups`), що унеможливлює його використання в інших Unix-подібних системах (наприклад, FreeBSD), тоді як SysVinit був більш "портируемий".

Незважаючи на критику, більшість великих дистрибутивів (Fedora, Debian, Ubuntu, Red Hat, SUSE) прийняли systemd через його ефективність і сучасні можливості.

[⬆️ На початок](#документація-по-systemd)

---

# Розділ 2. Ключові Компоненти systemd та Їх Функціональність

Systemd — це інтегрований фреймворк. Він складається з основного демона (systemd, PID 1) та комплексу допоміжних утиліт і юнітів, що керують системними ресурсами.

## 2.1. systemd: Головний Демон (PID 1)

Systemd — це не просто процес, а менеджер, який підтримує життєвий цикл операційної системи.

*   **Функція "Батька":** Як процес з PID 1, systemd є "прабатьком" усіх інших процесів. Якщо будь-який процес втрачає свого батька (наприклад, через збій), systemd автоматично усиновлює його. Це критично важливо, оскільки дозволяє коректно завершувати процеси, запобігаючи накопиченню так званих "зомбі-процесів" — ще одна проблема, характерна для старих систем ініціалізації.
*   **Управління Cgroups:** Systemd активно використовує контрольні групи Linux (cgroups). Кожен сервіс (юніт) отримує власний ізольований cgroup. Це дозволяє systemd точно відстежувати всі процеси, пов'язані з сервісом (включно з його дочірніми процесами), а також ефективно контролювати та обмежувати ресурси (CPU, пам'ять) для цього сервісу.

## 2.2. systemctl: Інструмент Уніфікованого Управління

`systemctl` (що розшифровується як **system control**) — це основна утиліта командного рядка для спілкування з головним демоном systemd. Вона замінює собою цілий набір команд SysVinit (`service`, `chkconfig`, `reboot`, `halt`).

| Категорія | Приклад Команди | Пояснення та Призначення |
| :--- | :--- | :--- |
| **Управління Сервісами** | `systemctl restart sshd.service` | Перезапускає демон SSH. На відміну від `stop` + `start`, це зазвичай відбувається швидше та безпечніше. |
| **Керування Автозавантаженням** | `systemctl enable firewalld` | Створює символічне посилання в директорії Target-юніта, щоб забезпечити запуск сервісу при старті системи. |
| **Статус та Діагностика** | `systemctl is-active postgresql.service` | Перевіряє, чи активний сервіс, повертаючи "active" або "inactive". |
| **Управління Системою** | `systemctl isolate graphical.target` | Перемикає систему в режим із графічним інтерфейсом. Це сучасний аналог зміни Runlevel. |
| **Перезавантаження Конфіга** | `systemctl daemon-reload` | Обов'язкова дія після ручної зміни будь-якого юніт-файлу. systemd перечитує нові конфігурації. |

## 2.3. journald: Централізоване Журналювання

`journald` — це інтегрований демон, який збирає та уніфікує всі системні логи: від ядра, від самого systemd та від усіх запущених сервісів.

*   **Переваги Бінарного Формату:** Логи зберігаються у структурованому, індексованому бінарному форматі, а не у звичайних текстових файлах. Це робить пошук, фільтрацію та аналіз логів надзвичайно швидким.
*   **Інструмент `journalctl`:** Це основний клієнт для перегляду цих бінарних логів.

| Приклад Команди | Призначення |
| :--- | :--- |
| `journalctl -u nginx.service` | Показати всі логи, що стосуються веб-сервера Nginx. |
| `journalctl -f` | Показати останні логи та очікувати на нові записи (аналог `tail -f`). |
| `journalctl -k` | Показати лише повідомлення ядра (kernel ring buffer). |
| `journalctl -b -1` | Показати логи попереднього завантаження системи. |
| `journalctl --since "1 hour ago"` | Показати логи, згенеровані за останню годину. |

## 2.4. Юніти (Unit Files): Мова Конфігурації systemd

Юніт — це базова одиниця управління, яка описує, як systemd має керувати певним системним ресурсом. Файли юнітів використовують простий декларативний INI-подібний формат.

### Ключовий Принцип: Декларативна Інструкція

Юніт — це декларативна інструкція на виконання, яка усуває необхідність писати складний Bash-код.

Замість того, щоб вказувати системі, *як* запустити сервіс (що вимагало б написання цілого скрипту з логікою перевірки статусу, зупинки, перезапуску та обробки сигналів, як це було у SysVinit), ви просто *декларуєте бажаний стан* та параметри:

*   **Що запустити?** (`ExecStart=`)
*   **Хто запускає?** (`User=`)
*   **Коли перезапускати?** (`Restart=on-failure`)
*   **Від чого залежить?** (`After=network.target`)

Systemd сам бере на себе всю складну логіку (обробку сигналів, відстеження cgroups, управління життєвим циклом, логування), звільняючи адміністратора від ручного програмування цих аспектів на Shell. Це значно спрощує конфігурацію і робить її менш схильною до помилок.

### Ключові Типи Юнітів:

| Тип Юніта | Розширення | Призначення | Розширений Приклад |
| :--- | :--- | :--- | :--- |
| **Service** | `.service` | Описує системний демон (фоновий процес). | Запуск веб-сервера Apache, бази даних MySQL, або кастомного Python-скрипта. |
| **Target** | `.target` | Групує інші юніти та визначає стан системи. | `multi-user.target` (багатокористувацький режим без GUI) або `graphical.target` (з GUI). Target-юніти замінюють Runlevels. |
| **Timer** | `.timer` | Альтернатива `cron`. Визначає завдання, яке запускає пов'язаний `.service` юніт за розкладом. | Запуск щоденного бекапу або очищення кешу щопонеділка. Перевага: Таймери успадковують всі залежності та логування від systemd. |
| **Socket** | `.socket` | Визначає мережевий або локальний сокет, який systemd прослуховує. При першому з'єднанні він активує пов'язаний `.service` юніт. | Використовується для рідкісно використовуваних сервісів (як `cups.socket` для друку) для економії ресурсів. |
| **Mount/Automount** | `.mount` / `.automount` | Керування точками монтування. systemd може динамічно створювати юніти, аналізуючи `/etc/fstab`. | Використання `automount` дозволяє відкласти монтування мережевих ресурсів (наприклад, NFS) до моменту, коли користувач спробує до них звернутися. |

## 2.5. systemd-analyze: Аналіз Продуктивності Завантаження

Systemd надає вбудовані інструменти для профілювання, що було неможливо в SysVinit.

*   **`systemd-analyze blame`**: Ця команда показує, скільки часу займав запуск кожного юніта під час останнього завантаження. Це надзвичайно корисно для виявлення "вузьких місць" і оптимізації часу старту системи.

    ```bash
    $ systemd-analyze blame

             1.258s network-online.target
              895ms mariadb.service 
              671ms postfix.service
              ... (інші сервіси)
    ```
    *(У прикладі видно, що найбільше часу займає очікування мережі та запуск MariaDB.)*

*   **`systemd-analyze`**: Показує загальний час, необхідний для завантаження ядра та завантаження юнітів.

[⬆️ На початок](#документація-по-systemd)

---

# 3. Управління Сервісами: Команда systemctl

Найчастіше адміністратори використовують `systemctl` для управління сервісами (`.service` юнітами). Нижче наведено зведення основних команд, згрупованих за функціональністю.

### Управління Сервісами (Базові команди)

| Команда | Призначення |
| :--- | :--- |
| `systemctl start <юніт>` | Запустити сервіс. |
| `systemctl stop <юніт>` | Зупинити сервіс. |
| `systemctl restart <юніт>` | Перезапустити сервіс. |
| `systemctl reload <юніт>` | Перезавантажити конфігурацію (без повного перезапуску, якщо сервіс це підтримує). |

### Керування Автозавантаженням

| Команда | Призначення |
| :--- | :--- |
| `systemctl enable <юніт>` | Додати сервіс в автозавантаження (створити символічне посилання). |
| `systemctl disable <юніт>` | Видалити сервіс з автозавантаження. |
| `systemctl enable --now <юніт>` | Увімкнути автозавантаження і одразу запустити сервіс. |

### Перевірка Стану

| Команда | Призначення |
| :--- | :--- |
| `systemctl status <юніт>` | Показати поточний стан, PID та останні записи журналу для юніта. |
| `systemctl is-active <юніт>` | Перевірити, чи активний юніт на даний момент. |
| `systemctl is-enabled <юніт>` | Перевірити, чи увімкнений юніт для автозавантаження. |

### Аналіз Юнітів та Залежностей

| Команда | Призначення |
| :--- | :--- |
| `systemctl list-units` | Показати список активних та завантажених юнітів. |
| `systemctl list-units --type service --all` | Вивести статус усіх сервісів (включно з неактивними). |
| `systemctl list-unit-files` | Показати список усіх юніт-файлів та їхній стан автозавантаження. |
| `systemctl cat <юніт>` | Показати вміст юніт-файлу. |
| `systemctl list-dependencies <юніт>` | Показати перелік залежностей юніту від інших. |

### Управління Системою та "Цілями" (Targets)

| Команда | Призначення |
| :--- | :--- |
| `systemctl daemon-reload` | Перечитати конфігурацію systemd після ручної зміни юнітів. |
| `systemctl get-default` | Показати `target`, який буде метою завантаження системи за замовчуванням. |
| `systemctl set-default <target>` | Задати `target` як мету завантаження за замовчуванням. |
| `systemctl isolate <target>` | Переключитися на вказаний `target` з усіма його залежностями. |
| `systemctl reboot` | Перезавантажити систему. |
| `systemctl poweroff` | Вимкнути систему. |

### Аналіз Продуктивності

| Команда | Призначення |
| :--- | :--- |
| `systemd-analyze blame` | Видати статистику часу завантаження кожного юніту. |
| `systemd-analyze plot > plot.svg` | Згенерувати графік завантаження у форматі SVG. |

---

## Альтернативні Способи Управління Сервісами

Крім `systemctl`, існують й інші способи, більшість з яких залежать від системи ініціалізації, що використовується у вашому дистрибутиві Linux. Ось основні альтернативи:

### 1. Класична система SysVinit
Це "старий" спосіб, який `systemd` замінив. На системах, що досі його використовують (або для зворотної сумісності), ви можете використовувати:

*   **Команда `service`:** Уніфікована обгортка для init-скриптів.
    ```bash
    service nginx start
    service sshd status
    ```
*   **Прямий виклик init-скриптів:** Виконання скриптів, що знаходяться в `/etc/init.d/`.
    ```bash
    /etc/init.d/apache2 restart
    ```
*   **Керування автозавантаженням:**
    *   `update-rc.d` (Debian/Ubuntu)
    *   `chkconfig` (Red Hat/CentOS)

### 2. Система Upstart
Це проміжна система ініціалізації, що використовувалася в Ubuntu. Вона керувала сервісами за допомогою інших команд:
```bash
start networking
stop avahi-daemon
restart cron
```

### 3. Специфічні для сервісу утиліти
Багато програм (особливо старіші) постачаються з власними скриптами управління. Найвідоміший приклад — веб-сервер Apache:
```bash
apachectl -k graceful 
# або
apache2ctl restart
```

### 4. Сучасний підхід: Контейнеризація та Оркестрація
У сучасній інфраструктурі життєвим циклом сервісів часто керують не на рівні ОС, а на вищому рівні абстракції:

*   **Docker:** Якщо ваш сервіс запущений як Docker-контейнер.
    ```bash
    docker start my-web-server
    docker stop my-database
    ```
*   **Kubernetes:** Для управління мікросервісами в кластері.
    ```bash
    kubectl scale deployment/my-app --replicas=3
    ```

[⬆️ На початок](#документація-по-systemd)

---

# 4. Журналювання: Команда journalctl

`systemd` збирає всі логи в централізованому двійковому форматі за допомогою демона `journald`. Для перегляду та аналізу цих логів використовується утиліта `journalctl` (що розшифровується як **journal control**).

### Основні Команди

| Команда | Призначення |
| :--- | :--- |
| `journalctl` | Показати всі логи системи, починаючи з найдавніших. |
| `journalctl -f` | Показати логи в реальному часі (аналог `tail -f`). |
| `journalctl -u <назва_сервісу>` | Показати логи лише для конкретного юніта (сервісу), наприклад `nginx.service`. |
| `journalctl -p err` | Фільтрувати логи за пріоритетом. Рівні: `emerg`, `alert`, `crit`, `err`, `warning`, `notice`, `info`, `debug`. |
| `journalctl -b` | Показати логи лише з поточного завантаження системи. |

### Розширені Можливості `journalctl`

| Команда | Призначення |
| :--- | :--- |
| `journalctl -b -1` | Показати логи з попереднього завантаження. `-2` — з позапопереднього, і так далі. |
| `journalctl -k` | Показати лише повідомлення ядра (аналог `dmesg`). |
| `journalctl --since "1 hour ago"` | Показати логи за останню годину. Також можна використовувати `yesterday`, `"2 days ago"`. |
| `journalctl --since "..." --until "..."` | Фільтрувати логи у часовому діапазоні. |
| `journalctl _PID=<номер_процесу>` | Фільтрувати логи за конкретним ID процесу. |
| `journalctl -o json-pretty` | Вивести логи у форматі JSON для зручної машинної обробки або аналізу. |

### Налаштування `journald` (Постійне Зберігання Лoгів)

За замовчуванням, у багатьох системах `journald` зберігає логи в пам'яті (`/run/log/journal/`), що означає їх втрату після перезавантаження. Щоб увімкнути постійне зберігання, потрібно створити відповідний каталог:

```bash
# Створення каталогу для постійного зберігання логів
mkdir -p /var/log/journal
```

Після цього `journald` автоматично почне записувати логи в цей каталог. Перезапустіть `journald`, щоб застосувати зміни негайно:

```bash
# Перезапуск демона журналювання
systemctl restart systemd-journald
```

#### Обмеження Розміру Журналу

Щоб логи не займали весь дисковий простір, їх розмір можна (і варто) обмежити. Для цього розкоментуйте та змініть відповідні рядки у файлі `/etc/systemd/journald.conf`:

```ini
[Journal]
# Обмежити максимальний розмір журналу на диску до 1 ГБ
SystemMaxUse=1G

# Обмежити розмір одного файлу журналу до 100 МБ
SystemMaxFileSize=100M
```

Після внесення змін не забудьте перезапустити сервіс:

```bash
systemctl restart systemd-journald
```

[⬆️ На початок](#документація-по-systemd)

---

# 5. Анатомія Файлу Service Unit

Файл юніта сервісу (`.service`) — це декларативний текстовий файл у форматі, подібному до INI, який описує, як `systemd` має керувати сервісом.

### Приклад файлу: `/etc/systemd/system/my_app.service`

Ось більш розширений приклад з коментарями, що демонструє найкращі практики:

```ini
# Секція [Unit] містить метадані та залежності
[Unit]
# Опис, який буде видно в `systemctl status`
Description=My Custom Python Web Application
# Документація, доступна через `systemctl help`
Documentation=man:my-app(8)

# Запускати цей сервіс тільки після того, як мережа буде готова
After=network.target

# Секція [Service] описує, як запускати та контролювати сервіс
[Service]
# Тип сервісу. `simple` (за замовчуванням) означає, що ExecStart - це головний процес
Type=simple

# Запускати від імені непривілейованого користувача для безпеки
User=myuser
Group=myuser

# Робоча директорія
WorkingDirectory=/opt/myapp

# Команда для запуску
ExecStart=/usr/bin/python3 /opt/myapp/app.py

# Команда для надсилання сигналу перезавантаження конфігурації
ExecReload=/bin/kill -HUP $MAINPID

# Політика перезапуску: перезапускати при будь-якому збої
Restart=on-failure
# Затримка перед перезапуском
RestartSec=5s

# Налаштування безпеки для ізоляції процесу
PrivateTmp=true
ProtectSystem=full
NoNewPrivileges=true

# Секція [Install] вказує, як поводитися при `systemctl enable`
[Install]
# Цей сервіс має бути частиною стандартного багатокористувацького режиму
WantedBy=multi-user.target
```

--- 

### Розбір Основних Секцій та Директив

Файл юніта systemd розділений на секції, кожна з яких відповідає за певний аспект конфігурації.

#### Секція `[Unit]`
Ця секція містить загальну інформацію про юніт, його опис, а також визначає залежності від інших юнітів. Залежності є критично важливими для правильного порядку запуску сервісів.

| Директива | Призначення | Детальніше |
| :--- | :--- | :--- |
| `Description` | Короткий, зрозумілий опис сервісу. | Цей опис відображається при використанні `systemctl status <юніт>` і допомагає ідентифікувати призначення сервісу. |
| `Documentation` | Посилання на документацію. | Може бути URL або посилання на man-сторінку (наприклад, `man:my-app(8)`). Дозволяє швидко отримати довідкову інформацію про сервіс. |
| `After` | **М'яка залежність.** | Вказує, що цей юніт повинен бути запущений *після* вказаних юнітів. Якщо юніт, зазначений в `After`, не запускається, це не зупинить запуск поточного юніта. Це найчастіше використовувана залежність для визначення порядку запуску. Наприклад, `After=network.target` гарантує, що мережа буде налаштована до запуску сервісу. |
| `Requires` | **Жорстка залежність.** | Вказує, що цей юніт *потребує* успішного запуску вказаних юнітів. Якщо будь-який з юнітів, зазначених у `Requires`, не запускається або зупиняється, поточний юніт також буде зупинено. Використовується для критичних залежностей. |
| `Wants` | Дуже м'яка залежність. | `systemd` спробує запустити вказані юніти, але не перейматиметься, якщо вони не запустяться або зупиняться. Це корисно для опціональних сервісів. |
| `BindsTo` | Дуже жорстка залежність. | Подібно до `Requires`, але якщо вказаний юніт зупиняється, поточний юніт буде примусово зупинено. Часто використовується для зв'язку з точками монтування (`.mount` юнітами). |
| `PartOf` | Групує юніти. | Вказує, що цей юніт є частиною іншого юніта. Запуск/зупинка батьківського юніта впливатиме на цей. |

#### Секція `[Service]`
Ця секція є серцем сервісного юніта, оскільки вона містить інструкції щодо того, як `systemd` повинен запускати, зупиняти, перезавантажувати та керувати життєвим циклом процесу сервісу.

| Директива | Призначення | Детальніше |
| :--- | :--- | :--- |
| `Type` | Тип запуску сервісу. | Визначає поведінку головного процесу. Найпоширеніші значення: <br> - `simple` (за замовчуванням): `ExecStart` запускає головний процес, який не розгалужується. `systemd` вважає сервіс запущеним, як тільки `ExecStart` виконається. <br> - `forking`: `ExecStart` запускає процес, який потім розгалужується (forks) і виходить, залишаючи дочірній процес як головний. `systemd` чекає, поки батьківський процес вийде. <br> - `oneshot`: Для скриптів, що виконуються один раз і завершуються. `systemd` чекає завершення `ExecStart`. <br> - `notify`: Сервіс надсилає сигнал `systemd` після завершення ініціалізації. |
| `ExecStart` | **Обов'язково.** Команда запуску. | Повний шлях та аргументи до команди, яка запускає основний процес сервісу. Це може бути виконуваний файл, скрипт тощо. |
| `ExecStop` | Команда зупинки. | Команда для коректної зупинки сервісу. Якщо не вказано, `systemd` надсилає `SIGTERM` (а потім `SIGKILL`, якщо сервіс не зупиняється). |
| `ExecReload` | Команда перезавантаження конфігурації. | Команда для перезавантаження конфігурації сервісу без його повного зупинки та запуску. Це дозволяє уникнути перерв у роботі. Наприклад, `ExecReload=/bin/kill -HUP $MAINPID` для Nginx. |
| `User`, `Group` | Користувач та група. | Запускає сервіс від імені вказаного непривілейованого користувача та групи замість `root`. **Це критично важливо для безпеки**, оскільки обмежує потенційну шкоду у випадку компрометації сервісу. |
| `Restart` | Політика перезапуску. | Визначає, коли `systemd` повинен автоматично перезапускати сервіс. Значення: <br> - `no`: Ніколи не перезапускати. <br> - `on-success`: Перезапускати, якщо сервіс завершився з "успішним" кодом виходу. <br> - `on-failure`: Перезапускати, якщо сервіс завершився з помилкою (найпоширеніший вибір). <br> - `on-abnormal`: Перезапускати, якщо сервіс завершився через сигнал або тайм-аут. <br> - `always`: Завжди перезапускати, незалежно від коду виходу. |
| `RestartSec` | Затримка перед перезапуском. | Час очікування в секундах перед спробою перезапуску сервісу після його зупинки. |
| `Environment` | Змінні середовища. | Встановлює змінні середовища для процесу сервісу (наприклад, `Environment="DB_HOST=localhost" "PORT=8080"`). |
| `WorkingDirectory` | Робочий каталог. | Встановлює робочий каталог для процесу сервісу. Всі відносні шляхи в `ExecStart` будуть інтерпретуватися відносно цього каталогу. |
| `PrivateTmp` | Приватний `/tmp`. | Якщо `true`, сервіс отримує власний приватний каталог `/tmp` та `/var/tmp`, ізолюючи його від інших процесів. Покращує безпеку. |
| `ProtectSystem` | Захист системних каталогів. | Обмежує доступ сервісу до системних каталогів. `full` робить `/usr`, `/boot`, `/etc` доступними лише для читання. |
| `NoNewPrivileges` | Заборона підвищення привілеїв. | Запобігає підвищенню привілеїв процесом сервісу. |

#### Секція `[Install]`
Ця секція не використовується самим `systemd` під час роботи системи, а лише командою `systemctl enable`. Вона визначає, як юніт повинен бути інтегрований у систему для автоматичного запуску при завантаженні.

| Директива | Призначення | Детальніше |
| :--- | :--- | :--- |
| `WantedBy` | **Вказує Target.** | Ця директива є ключовою для автозавантаження. Вона вказує, до якого "цільового" юніта (`.target`) цей сервіс повинен бути прив'язаний. Коли ви виконуєте `systemctl enable <юніт>`, `systemd` створює символічне посилання на цей юніт у каталозі `.wants` відповідного `target` юніта. <br><br> **Приклад:** `WantedBy=multi-user.target` означає, що сервіс буде запущений, коли система досягне стану "багатокористувацького режиму без графічного інтерфейсу". Це стандартний вибір для більшості фонових сервісів. Інші поширені `target` юніти включають `graphical.target` (для сервісів, що потребують GUI) або кастомні `target` юніти, які ви можете створити для групування власних сервісів. |
| `RequiredBy` | Вказує Target (жорстка залежність). | Подібно до `WantedBy`, але створює жорстку залежність. Якщо `target` юніт, зазначений тут, запускається, то цей сервіс також повинен бути запущений. Якщо цей сервіс не запускається, `target` юніт також не зможе запуститися. |
| `Alias` | Створює додаткове ім'я. | Дозволяє звертатися до цього юніта за іншим ім'ям. |

--- 

### Типовий Робочий Процес

1.  **Створити/змінити файл:** Створіть файл `.service` у каталозі `/etc/systemd/system/`.
2.  **Перезавантажити конфігурацію:** Повідомте `systemd` про новий або змінений файл.
    ```bash
    systemctl daemon-reload
    ```
3.  **Запустити та увімкнути:** Запустіть сервіс та додайте його в автозавантаження.
    ```bash
    systemctl enable --now my_app.service
    ```

[⬆️ На початок](#документація-по-systemd)

---

# 6. Додаток: Приклад Init-скрипта в SysVinit

Щоб краще зрозуміти, наскільки `systemd` спростив управління сервісами, корисно поглянути на те, як виглядав типовий скрипт ініціалізації в старій системі **SysVinit**.

Скрипти зазвичай розміщувалися в `/etc/init.d/` і були написані на `bash`. Вони мали складну логіку для запуску, зупинки, перевірки статусу та управління PID-файлами.

### Приклад: `/etc/init.d/my_app`

Ось як міг би виглядати скрипт для управління простою кастомною програмою `my_app_daemon`:

```bash
#!/bin/bash
#
# my_app      Startup script for my_app_daemon
#
# chkconfig: 2345 90 10
# description: My App is a sample daemon.
# processname: my_app_daemon
# pidfile: /var/run/my_app_daemon.pid

# Source function library.
. /etc/rc.d/init.d/functions

# Шлях до виконуваного файлу
DAEMON_PATH="/usr/local/sbin/my_app_daemon"
# Назва процесу
NAME="my_app_daemon"
# Опис
DESC="My App Daemon"
# PID файл
PID_FILE="/var/run/${NAME}.pid"
# Користувач, від імені якого запускати
RUN_AS="myuser"

# Перевірка наявності виконуваного файлу
test -x $DAEMON_PATH || exit 0

start() {
    echo -n "Starting $DESC: "
    # Використовуємо `daemon` для запуску в фоновому режимі
    # та створення PID-файлу
    daemon --user $RUN_AS --pidfile $PID_FILE $DAEMON_PATH
    RETVAL=$?
    echo
    [ $RETVAL -eq 0 ] && touch /var/lock/subsys/$NAME
    return $RETVAL
}

stop() {
    echo -n "Stopping $DESC: "
    # Використовуємо `killproc` для зупинки процесу за PID-файлом
    killproc -p $PID_FILE $NAME
    RETVAL=$?
    echo
    [ $RETVAL -eq 0 ] && rm -f /var/lock/subsys/$NAME $PID_FILE
    return $RETVAL
}

restart() {
    stop
    start
}

status() {
    # Перевірка статусу за допомогою функції `status`
    status -p $PID_FILE $NAME
}

# Обробка аргументів командного рядка
case "$1" in
  start)
    start
    ;;
  stop)
    stop
    ;;
  restart)
    restart
    ;;
  status)
    status
    ;;
  *)
    echo "Usage: $0 {start|stop|restart|status}"
    exit 1
esac

exit $?
```

### Ключові відмінності від `systemd`

1.  **Імперативний підхід:** Скрипт є послідовністю команд (`if`, `case`, `echo`). Ви *програмуєте*, як керувати сервісом. У `systemd` ви *декларуєте* бажаний стан.
2.  **Ручне управління PID:** Скрипт відповідає за створення та видалення PID-файлу (`/var/run/my_app_daemon.pid`), щоб відстежувати процес. `systemd` робить це автоматично за допомогою `cgroups`.
3.  **Складність:** Навіть для простого сервісу потрібно написати близько 50 рядків коду на `bash`, включаючи обробку помилок та логіку для кожної дії (`start`, `stop`, `restart`). В `systemd` аналогічний сервіс описується 10-15 рядками конфігурації.
4.  **Залежності:** Залежності керувалися за допомогою нумерованих символічних посилань у каталогах `rc.d`, що було негнучко і складно в управлінні.

Цей приклад наочно демонструє, чому `systemd` став сучасним стандартом, пропонуючи більш надійний, простий та потужний підхід до управління системними процесами.

[⬆️ На початок](#документація-по-systemd)
