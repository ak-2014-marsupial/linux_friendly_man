# Документація по Systemd

## Зміст

*   [Розділ 1. Еволюція Системи Ініціалізації Linux: Від SysVinit до systemd](#розділ-1-еволюція-системи-ініціалізації-linux-від-sysvinit-до-systemd)
*   [Розділ 2. Ключові Компоненти systemd та Їх Функціональність](#розділ-2-ключові-компоненти-systemd-та-їх-функціональність)
*   [Розділ 3. Управління Сервісами: Команда systemctl](#3-управління-сервісами-команда-systemctl)
*   [Розділ 4. Журналювання: Команда journalctl](#4-журналювання-команда-journalctl)
*   [Розділ 5. Анатомія Файлу Service Unit](#5-анатомія-файлу-service-unit)

---

# Розділ 1. Еволюція Системи Ініціалізації Linux: Від SysVinit до systemd

Systemd є не просто менеджером сервісів, це фундаментальна зміна в архітектурі Linux. Щоб повністю зрозуміти його важливість, необхідно подивитися на те, як система працювала раніше.

## 1.1 Історичний Контекст: Ера SysVinit та Його Обмеження (До 2010)

Протягом десятиліть домінувала система ініціалізації SysVinit (System V init).

**Як це працювало:**

*   **Головний процес (PID 1):** SysVinit був процесом з ідентифікатором PID 1, який запускався ядром першим.
*   **Сценарії Shell:** Для запуску сервісів використовувалися послідовні shell-скрипти (зазвичай bash), розташовані в каталогах на кшталт `/etc/init.d/`.
*   **Рівні запуску (Runlevels):** Система використовувала числові рівні запуску (runlevels), наприклад, `runlevel 3` для багатокористувацького режиму без GUI, `runlevel 5` для графічного режиму. Ці рівні визначали, які скрипти мають бути виконані.

### Проблеми та Обмеження SysVinit

| Проблема | Пояснення |
| :--- | :--- |
| **Послідовний запуск (Sequence Startup)** | Скрипти виконувалися один за одним. Якщо один скрипт зависав або був повільним (наприклад, перевірка мережі), вся система чекала. **Результат:** Дуже повільний час завантаження, особливо на великих серверах. |
| **"Залежності" через символічні посилання** | Залежності між сервісами (наприклад, веб-серверу потрібна база даних) керувалися заплутаною системою нумерованих символічних посилань (напр. `S20myservice`, `S21another`) у каталогах runlevel. Це було складно підтримувати. |
| **Відсутність відстеження процесів** | SysVinit не міг відстежувати всі дочірні процеси, які створював сервіс (коли процес "відгалужувався" або fork'ався). Якщо головний процес помирав, дочірні процеси могли залишитися "зомбі" або просто без контролю. |
| **Складність конфігурації** | Скрипти були написані мовою Shell, що вимагало знання складних інструкцій і було схильне до помилок. |

### Але... З'явився systemd (2010)

Вимоги до сучасних систем (швидкий запуск, маштабованість, контейнеризація) зробили SysVinit застарілим. Двоє програмістів Red Hat, Леннарт Поеттерінг та Кей Сіверс, розробили systemd, щоб вирішити ці проблеми, беручи натхнення від таких систем, як `launchd` (macOS).

## 1.2 systemd: Нова Філософія та Архітектура

systemd — це не просто заміна SysVinit. Це цілий фреймворк для керування системою, який використовує сучасні функції ядра Linux.

### A. systemd як Головний Процес (PID 1)

*   **Призначення:** Як і SysVinit, systemd отримує PID 1. Він є коренем усіх процесів.
*   **Чому це важливо:** Якщо будь-який процес у системі втрачає свого батька (наприклад, батьківський процес завершується), ядро автоматично перепризначає systemd як нового батька. Це дозволяє systemd "усиновлювати" ці процеси та коректно їх завершувати (запобігаючи "зомбі-процесам"), на відміну від старих систем.
*   **Залежність від Linux:** systemd спочатку розроблявся виключно для Linux. Він активно використовує такі функції ядра, як `cgroups` (контрольні групи) для відстеження процесів та `fanotify` для моніторингу файлової системи.

### B. Концепція Юнітів (Unit Files)

Юніт — це базова одиниця конфігурації в systemd. Це простий текстовий файл (формату `.ini`), який декларативно описує, як керувати певним ресурсом (сервісом, точкою монтування, таймером).

**Розширене пояснення:**

*   **Декларативність:** Замість складного shell-скрипта (як у SysVinit), ви просто декларуєте бажаний стан: "запустити цей файл", "після мережі", "перезапускати при помилці".
*   **Розташування:**
    *   `/usr/lib/systemd/system/`: Юніти, які постачаються встановленими пакетами.
    *   `/etc/systemd/system/`: Юніти, створені або модифіковані системним адміністратором. Цей каталог має пріоритет.

### C. Активація на Вимогу (Activation)

Це ключова функція, що забезпечує швидкість і економію ресурсів, яка була недоступна у SysVinit.

*   **Активація через Сокет (`.socket`):**
    *   **Приклад:** Уявіть, що у вас є рідкісно використовуваний поштовий сервер (SMTP). Замість того, щоб тримати його постійно запущеним (як у SysVinit), systemd може слухати порт 25 (SMTP) через юніт `.socket`.
    *   Коли надходить перший мережевий запит на порт 25, тільки тоді systemd автоматично запускає відповідний `.service` юніт. Після обробки запиту сервіс може вимкнутися.
    *   **Перевага:** Економія RAM і процесорного часу для сервісів, які не потрібні 24/7.
*   **Активація через D-Bus:**
    *   Сервіс запускається, коли інша програма надсилає запит через системну шину D-Bus.

### D. Systemctl: Централізований Інтерфейс Управління

`systemctl` замінив безліч окремих команд (`service`, `chkconfig`, `initctl`) на єдиний інструмент.

**Розширене пояснення та Приклади:**

*   **Універсальність:** Незалежно від дистрибутива (Ubuntu, Fedora, Arch), команда для управління сервісом завжди однакова.
    *   **SysVinit:** Ви могли мати `service apache2 start` на Debian, але `/etc/init.d/httpd start` на Red Hat.
    *   **Systemd:** `systemctl start apache2.service` — працює скрізь.
*   **Перезавантаження конфігурації:**
    *   Ви внесли зміни до конфігураційного файлу вашого веб-сервера Nginx (`/etc/nginx/nginx.conf`).
    *   `systemctl reload nginx.service` — systemd надсилає сигнал Nginx'у, щоб він перечитав свій конфіг без зупинки роботи, зберігаючи активні з'єднання. Це набагато ефективніше, ніж повний `restart`.

### E. Journald: Інтегрована Система Журналювання

В SysVinit логи були розкидані по різних текстових файлах (`/var/log/messages`, `/var/log/syslog`, `/var/log/apache2/error.log`).

**Розширене пояснення:**

*   **Централізація та Бінарний Формат:** `journald` збирає всі логи в одному місці (зазвичай `/var/log/journal/`) у бінарному форматі. Це дозволяє логам бути структурованими, індексованими та дуже швидкими для пошуку.
*   **Потужний Фільтр `journalctl`:** На відміну від простого `grep` або `tail`, `journalctl` дозволяє швидко отримувати саме ту інформацію, яка вам потрібна, незалежно від того, коли вона була згенерована.
    *   **Приклад:** Якщо ви хочете побачити всі повідомлення, які генерував SSH-сервер за останні 30 хвилин:
        ```bash
        journalctl -u sshd --since "30 minutes ago"
        ```
    *   **Приклад:** Подивитися, що сталося в системі під час попереднього завантаження (дуже корисно для діагностики):
        ```bash
        journalctl -b -1
        ```

---



## 1.3 Суперечності та Критика systemd

Хоча systemd приніс беззаперечні переваги, його впровадження викликало одну з найбільших суперечок у спільноті відкритого коду.

*   **Порушення Принципу KISS (Keep It Simple, Stupid):** Критики стверджують, що systemd "робить занадто багато". Він об'єднав функції ініціалізації, логування, мережевого управління (через `systemd-networkd`), DNS-резолвінгу (через `systemd-resolved`) та інші. Вони вважають, що це створює надто велику, монолітну та складну систему.
*   **Залежність від Linux:** systemd покладається на Linux-специфічні функції (напр. `cgroups`), що унеможливлює його використання в інших Unix-подібних системах (наприклад, FreeBSD), тоді як SysVinit був більш "портируемий".

Незважаючи на критику, більшість великих дистрибутивів (Fedora, Debian, Ubuntu, Red Hat, SUSE) прийняли systemd через його ефективність і сучасні можливості.

[⬆️ На початок](#документація-по-systemd)

---

# Розділ 2. Ключові Компоненти systemd та Їх Функціональність

Systemd — це інтегрований фреймворк. Він складається з основного демона (systemd, PID 1) та комплексу допоміжних утиліт і юнітів, що керують системними ресурсами.

## 2.1. systemd: Головний Демон (PID 1)

Systemd — це не просто процес, а менеджер, який підтримує життєвий цикл операційної системи.

*   **Функція "Батька":** Як процес з PID 1, systemd є "прабатьком" усіх інших процесів. Якщо будь-який процес втрачає свого батька (наприклад, через збій), systemd автоматично усиновлює його. Це критично важливо, оскільки дозволяє коректно завершувати процеси, запобігаючи накопиченню так званих "зомбі-процесів" — ще одна проблема, характерна для старих систем ініціалізації.
*   **Управління Cgroups:** Systemd активно використовує контрольні групи Linux (cgroups). Кожен сервіс (юніт) отримує власний ізольований cgroup. Це дозволяє systemd точно відстежувати всі процеси, пов'язані з сервісом (включно з його дочірніми процесами), а також ефективно контролювати та обмежувати ресурси (CPU, пам'ять) для цього сервісу.

## 2.2. systemctl: Інструмент Уніфікованого Управління

`systemctl` — це основна утиліта командного рядка для спілкування з головним демоном systemd. Вона замінює собою цілий набір команд SysVinit (`service`, `chkconfig`, `reboot`, `halt`).

| Категорія | Приклад Команди | Пояснення та Призначення |
| :--- | :--- | :--- |
| **Управління Сервісами** | `systemctl restart sshd.service` | Перезапускає демон SSH. На відміну від `stop` + `start`, це зазвичай відбувається швидше та безпечніше. |
| **Керування Автозавантаженням** | `systemctl enable firewalld` | Створює символічне посилання в директорії Target-юніта, щоб забезпечити запуск сервісу при старті системи. |
| **Статус та Діагностика** | `systemctl is-active postgresql.service` | Перевіряє, чи активний сервіс, повертаючи "active" або "inactive". |
| **Управління Системою** | `systemctl isolate graphical.target` | Перемикає систему в режим із графічним інтерфейсом. Це сучасний аналог зміни Runlevel. |
| **Перезавантаження Конфіга** | `systemctl daemon-reload` | Обов'язкова дія після ручної зміни будь-якого юніт-файлу. systemd перечитує нові конфігурації. |

## 2.3. journald: Централізоване Журналювання

`journald` — це інтегрований демон, який збирає та уніфікує всі системні логи: від ядра, від самого systemd та від усіх запущених сервісів.

*   **Переваги Бінарного Формату:** Логи зберігаються у структурованому, індексованому бінарному форматі, а не у звичайних текстових файлах. Це робить пошук, фільтрацію та аналіз логів надзвичайно швидким.
*   **Інструмент `journalctl`:** Це основний клієнт для перегляду цих бінарних логів.

| Приклад Команди | Призначення |
| :--- | :--- |
| `journalctl -u nginx.service` | Показати всі логи, що стосуються веб-сервера Nginx. |
| `journalctl -f` | Показати останні логи та очікувати на нові записи (аналог `tail -f`). |
| `journalctl -k` | Показати лише повідомлення ядра (kernel ring buffer). |
| `journalctl -b -1` | Показати логи попереднього завантаження системи. |
| `journalctl --since "1 hour ago"` | Показати логи, згенеровані за останню годину. |

## 2.4. Юніти (Unit Files): Мова Конфігурації systemd

Юніт — це базова одиниця управління, яка описує, як systemd має керувати певним системним ресурсом. Файли юнітів використовують простий декларативний INI-подібний формат.

### Ключовий Принцип: Декларативна Інструкція

Юніт — це декларативна інструкція на виконання, яка усуває необхідність писати складний Bash-код.

Замість того, щоб вказувати системі, *як* запустити сервіс (що вимагало б написання цілого скрипту з логікою перевірки статусу, зупинки, перезапуску та обробки сигналів, як це було у SysVinit), ви просто *декларуєте бажаний стан* та параметри:

*   **Що запустити?** (`ExecStart=`)
*   **Хто запускає?** (`User=`)
*   **Коли перезапускати?** (`Restart=on-failure`)
*   **Від чого залежить?** (`After=network.target`)

Systemd сам бере на себе всю складну логіку (обробку сигналів, відстеження cgroups, управління життєвим циклом, логування), звільняючи адміністратора від ручного програмування цих аспектів на Shell. Це значно спрощує конфігурацію і робить її менш схильною до помилок.

### Ключові Типи Юнітів:

| Тип Юніта | Розширення | Призначення | Розширений Приклад |
| :--- | :--- | :--- | :--- |
| **Service** | `.service` | Описує системний демон (фоновий процес). | Запуск веб-сервера Apache, бази даних MySQL, або кастомного Python-скрипта. |
| **Target** | `.target` | Групує інші юніти та визначає стан системи. | `multi-user.target` (багатокористувацький режим без GUI) або `graphical.target` (з GUI). Target-юніти замінюють Runlevels. |
| **Timer** | `.timer` | Альтернатива `cron`. Визначає завдання, яке запускає пов'язаний `.service` юніт за розкладом. | Запуск щоденного бекапу або очищення кешу щопонеділка. Перевага: Таймери успадковують всі залежності та логування від systemd. |
| **Socket** | `.socket` | Визначає мережевий або локальний сокет, який systemd прослуховує. При першому з'єднанні він активує пов'язаний `.service` юніт. | Використовується для рідкісно використовуваних сервісів (як `cups.socket` для друку) для економії ресурсів. |
| **Mount/Automount** | `.mount` / `.automount` | Керування точками монтування. systemd може динамічно створювати юніти, аналізуючи `/etc/fstab`. | Використання `automount` дозволяє відкласти монтування мережевих ресурсів (наприклад, NFS) до моменту, коли користувач спробує до них звернутися. |

## 2.5. systemd-analyze: Аналіз Продуктивності Завантаження

Systemd надає вбудовані інструменти для профілювання, що було неможливо в SysVinit.

*   **`systemd-analyze blame`**: Ця команда показує, скільки часу займав запуск кожного юніта під час останнього завантаження. Це надзвичайно корисно для виявлення "вузьких місць" і оптимізації часу старту системи.

    ```bash
    $ systemd-analyze blame

             1.258s network-online.target
              895ms mariadb.service 
              671ms postfix.service
              ... (інші сервіси)
    ```
    *(У прикладі видно, що найбільше часу займає очікування мережі та запуск MariaDB.)*

*   **`systemd-analyze`**: Показує загальний час, необхідний для завантаження ядра та завантаження юнітів.

[⬆️ На початок](#документація-по-systemd)

---

# 3. Управління Сервісами: Команда systemctl

Найчастіше адміністратори використовують `systemctl` для управління сервісами (`.service` юнітами). Нижче наведено зведення основних команд, згрупованих за функціональністю.

### Управління Сервісами (Базові команди)

| Команда | Призначення |
| :--- | :--- |
| `systemctl start <юніт>` | Запустити сервіс. |
| `systemctl stop <юніт>` | Зупинити сервіс. |
| `systemctl restart <юніт>` | Перезапустити сервіс. |
| `systemctl reload <юніт>` | Перезавантажити конфігурацію (без повного перезапуску, якщо сервіс це підтримує). |

### Керування Автозавантаженням

| Команда | Призначення |
| :--- | :--- |
| `systemctl enable <юніт>` | Додати сервіс в автозавантаження (створити символічне посилання). |
| `systemctl disable <юніт>` | Видалити сервіс з автозавантаження. |
| `systemctl enable --now <юніт>` | Увімкнути автозавантаження і одразу запустити сервіс. |

### Перевірка Стану

| Команда | Призначення |
| :--- | :--- |
| `systemctl status <юніт>` | Показати поточний стан, PID та останні записи журналу для юніта. |
| `systemctl is-active <юніт>` | Перевірити, чи активний юніт на даний момент. |
| `systemctl is-enabled <юніт>` | Перевірити, чи увімкнений юніт для автозавантаження. |

### Аналіз Юнітів та Залежностей

| Команда | Призначення |
| :--- | :--- |
| `systemctl list-units` | Показати список активних та завантажених юнітів. |
| `systemctl list-units --type service --all` | Вивести статус усіх сервісів (включно з неактивними). |
| `systemctl list-unit-files` | Показати список усіх юніт-файлів та їхній стан автозавантаження. |
| `systemctl cat <юніт>` | Показати вміст юніт-файлу. |
| `systemctl list-dependencies <юніт>` | Показати перелік залежностей юніту від інших. |

### Управління Системою та "Цілями" (Targets)

| Команда | Призначення |
| :--- | :--- |
| `systemctl daemon-reload` | Перечитати конфігурацію systemd після ручної зміни юнітів. |
| `systemctl get-default` | Показати `target`, який буде метою завантаження системи за замовчуванням. |
| `systemctl set-default <target>` | Задати `target` як мету завантаження за замовчуванням. |
| `systemctl isolate <target>` | Переключитися на вказаний `target` з усіма його залежностями. |
| `systemctl reboot` | Перезавантажити систему. |
| `systemctl poweroff` | Вимкнути систему. |

### Аналіз Продуктивності

| Команда | Призначення |
| :--- | :--- |
| `systemd-analyze blame` | Видати статистику часу завантаження кожного юніту. |
| `systemd-analyze plot > plot.svg` | Згенерувати графік завантаження у форматі SVG. |

---

## Альтернативні Способи Управління Сервісами

Крім `systemctl`, існують й інші способи, більшість з яких залежать від системи ініціалізації, що використовується у вашому дистрибутиві Linux. Ось основні альтернативи:

### 1. Класична система SysVinit
Це "старий" спосіб, який `systemd` замінив. На системах, що досі його використовують (або для зворотної сумісності), ви можете використовувати:

*   **Команда `service`:** Уніфікована обгортка для init-скриптів.
    ```bash
    service nginx start
    service sshd status
    ```
*   **Прямий виклик init-скриптів:** Виконання скриптів, що знаходяться в `/etc/init.d/`.
    ```bash
    /etc/init.d/apache2 restart
    ```
*   **Керування автозавантаженням:**
    *   `update-rc.d` (Debian/Ubuntu)
    *   `chkconfig` (Red Hat/CentOS)

### 2. Система Upstart
Це проміжна система ініціалізації, що використовувалася в Ubuntu. Вона керувала сервісами за допомогою інших команд:
```bash
start networking
stop avahi-daemon
restart cron
```

### 3. Специфічні для сервісу утиліти
Багато програм (особливо старіші) постачаються з власними скриптами управління. Найвідоміший приклад — веб-сервер Apache:
```bash
apachectl -k graceful 
# або
apache2ctl restart
```

### 4. Сучасний підхід: Контейнеризація та Оркестрація
У сучасній інфраструктурі життєвим циклом сервісів часто керують не на рівні ОС, а на вищому рівні абстракції:

*   **Docker:** Якщо ваш сервіс запущений як Docker-контейнер.
    ```bash
    docker start my-web-server
    docker stop my-database
    ```
*   **Kubernetes:** Для управління мікросервісами в кластері.
    ```bash
    kubectl scale deployment/my-app --replicas=3
    ```

[⬆️ На початок](#документація-по-systemd)

---

# 4. Журналювання: Команда journalctl

`systemd` збирає всі логи в централізованому двійковому форматі за допомогою демона `journald`. Для перегляду та аналізу цих логів використовується утиліта `journalctl`.

### Основні Команди

| Команда | Призначення |
| :--- | :--- |
| `journalctl` | Показати всі логи системи, починаючи з найдавніших. |
| `journalctl -f` | Показати логи в реальному часі (аналог `tail -f`). |
| `journalctl -u <назва_сервісу>` | Показати логи лише для конкретного юніта (сервісу), наприклад `nginx.service`. |
| `journalctl -p err` | Фільтрувати логи за пріоритетом. Рівні: `emerg`, `alert`, `crit`, `err`, `warning`, `notice`, `info`, `debug`. |
| `journalctl -b` | Показати логи лише з поточного завантаження системи. |

### Розширені Можливості `journalctl`

| Команда | Призначення |
| :--- | :--- |
| `journalctl -b -1` | Показати логи з попереднього завантаження. `-2` — з позапопереднього, і так далі. |
| `journalctl -k` | Показати лише повідомлення ядра (аналог `dmesg`). |
| `journalctl --since "1 hour ago"` | Показати логи за останню годину. Також можна використовувати `yesterday`, `"2 days ago"`. |
| `journalctl --since "..." --until "..."` | Фільтрувати логи у часовому діапазоні. |
| `journalctl _PID=<номер_процесу>` | Фільтрувати логи за конкретним ID процесу. |
| `journalctl -o json-pretty` | Вивести логи у форматі JSON для зручної машинної обробки або аналізу. |

### Налаштування `journald` (Постійне Зберігання Лoгів)

За замовчуванням, у багатьох системах `journald` зберігає логи в пам'яті (`/run/log/journal/`), що означає їх втрату після перезавантаження. Щоб увімкнути постійне зберігання, потрібно створити відповідний каталог:

```bash
# Створення каталогу для постійного зберігання логів
mkdir -p /var/log/journal
```

Після цього `journald` автоматично почне записувати логи в цей каталог. Перезапустіть `journald`, щоб застосувати зміни негайно:

```bash
# Перезапуск демона журналювання
systemctl restart systemd-journald
```

#### Обмеження Розміру Журналу

Щоб логи не займали весь дисковий простір, їх розмір можна (і варто) обмежити. Для цього розкоментуйте та змініть відповідні рядки у файлі `/etc/systemd/journald.conf`:

```ini
[Journal]
# Обмежити максимальний розмір журналу на диску до 1 ГБ
SystemMaxUse=1G

# Обмежити розмір одного файлу журналу до 100 МБ
SystemMaxFileSize=100M
```

Після внесення змін не забудьте перезапустити сервіс:

```bash
systemctl restart systemd-journald
```

[⬆️ На початок](#документація-по-systemd)

---

# 5. Анатомія Файлу Service Unit

Файл юніта сервісу (`.service`) — це декларативний текстовий файл у форматі, подібному до INI, який описує, як `systemd` має керувати сервісом.

### Приклад файлу: `/etc/systemd/system/my_app.service`

Ось більш розширений приклад з коментарями, що демонструє найкращі практики:

```ini
# Секція [Unit] містить метадані та залежності
[Unit]
# Опис, який буде видно в `systemctl status`
Description=My Custom Python Web Application
# Документація, доступна через `systemctl help`
Documentation=man:my-app(8)

# Запускати цей сервіс тільки після того, як мережа буде готова
After=network.target

# Секція [Service] описує, як запускати та контролювати сервіс
[Service]
# Тип сервісу. `simple` (за замовчуванням) означає, що ExecStart - це головний процес
Type=simple

# Запускати від імені непривілейованого користувача для безпеки
User=myuser
Group=myuser

# Робоча директорія
WorkingDirectory=/opt/myapp

# Команда для запуску
ExecStart=/usr/bin/python3 /opt/myapp/app.py

# Команда для надсилання сигналу перезавантаження конфігурації
ExecReload=/bin/kill -HUP $MAINPID

# Політика перезапуску: перезапускати при будь-якому збої
Restart=on-failure
# Затримка перед перезапуском
RestartSec=5s

# Налаштування безпеки для ізоляції процесу
PrivateTmp=true
ProtectSystem=full
NoNewPrivileges=true

# Секція [Install] вказує, як поводитися при `systemctl enable`
[Install]
# Цей сервіс має бути частиною стандартного багатокористувацького режиму
WantedBy=multi-user.target
```

--- 

### Розбір Основних Секцій та Директив

#### Секція `[Unit]`
Містить загальну інформацію про юніт та його залежності від інших юнітів.

| Директива | Призначення |
| :--- | :--- |
| `Description` | Короткий, зрозумілий опис сервісу. |
| `Documentation` | Посилання на документацію (URL або `man:` сторінка). |
| `After` | **М'яка залежність.** Запускає цей юніт *після* вказаних. Найчастіший випадок. |
| `Requires` | **Жорстка залежність.** Запускає цей юніт *разом* із вказаними. Якщо `Requires` юніт падає, цей юніт також зупиняється. |
| `Wants` | Дуже м'яка залежність. `systemd` спробує запустити вказані юніти, але не перейматиметься, якщо вони не запустяться. |
| `BindsTo` | Дуже жорстка залежність. Якщо вказаний юніт зупиняється, цей юніт також буде примусово зупинено. |

#### Секція `[Service]`
Містить інструкції щодо запуску та керування процесом сервісу.

| Директива | Призначення |
| :--- | :--- |
| `Type` | Тип запуску: `simple` (процес не розгалужується), `forking` (процес створює дочірній процес, який і є головним), `oneshot` (для скриптів, що виконуються один раз). |
| `ExecStart` | **Обов'язково.** Повний шлях та аргументи до команди, що запускає сервіс. |
| `ExecStop` | Команда для коректної зупинки сервісу. |
| `ExecReload` | Команда для перезавантаження конфігурації без зупинки сервісу. |
| `User`, `Group` | Запуск від імені вказаного користувача/групи замість `root`. **Критично для безпеки.** |
| `Restart` | Політика перезапуску: `no` (ніколи), `on-success`, `on-failure`, `on-abnormal`, `always`. |
| `RestartSec` | Час очікування в секундах перед спробою перезапуску. |
| `Environment` | Встановлення змінних середовища для процесу (напр., `Environment="DB_HOST=localhost"`). |
| `WorkingDirectory` | Встановлює робочий каталог для процесу. |

#### Секція `[Install]`
Містить інформацію для команди `systemctl enable`, яка створює символічні посилання для автозавантаження.

| Директива | Призначення |
| :--- | :--- |
| `WantedBy` | Вказує, для якого `target` (стану системи) цей сервіс має бути увімкнений. `multi-user.target` — стандартний вибір для більшості сервісів. |
| `Alias` | Створює додаткове ім'я (псевдонім) для цього юніта. |

--- 

### Типовий Робочий Процес

1.  **Створити/змінити файл:** Створіть файл `.service` у каталозі `/etc/systemd/system/`.
2.  **Перезавантажити конфігурацію:** Повідомте `systemd` про новий або змінений файл.
    ```bash
    systemctl daemon-reload
    ```
3.  **Запустити та увімкнути:** Запустіть сервіс та додайте його в автозавантаження.
    ```bash
    systemctl enable --now my_app.service
    ```

[⬆️ На початок](#документація-по-systemd)