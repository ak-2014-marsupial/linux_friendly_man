Гаразд, ось відповіді та пояснення до лабораторної роботи по роботі з файлами.

### **1. Налаштування**
*   **Дія:**
    Потрібно відкрити два окремі термінали (або дві вкладки в одному терміналі) і підключитися до віртуальної машини по SSH в кожному з них.
*   **Створення директорії (в Терміналі 1):**
    ```bash
    mkdir ~/lab-files
    cd ~/lab-files
    ```
*   **Пояснення:**
    Ми створюємо директорію `lab-files` у домашньому каталозі (`~`) і одразу переходимо в неї. Всі подальші дії до пункту 6 виконуємо тут.

### **2. Створення файлу**
*   **Команда:**
    ```bash
    touch main-file
    ```
*   **Пояснення:**
    Команда `touch` створює порожній файл з вказаним ім'ям, якщо він не існує, або оновлює час його останньої модифікації, якщо він існує.

### **3. Символічні посилання**
*   **Команди:**
    ```bash
    ln -s main-file link-file
    ls -li main-file link-file
    stat main-file link-file
    ln -s . link-dir
    ls -li link-dir
    ```
*   **Пояснення:**
    *   `ln -s`: створює символічне (м'яке) посилання.
    *   `ls -li`: показує список файлів з їхніми номерами inode (`-i`). Ви побачите, що `main-file` і `link-file` мають **різні** номери inode.
    *   `stat`: показує детальну метаінформацію. Для `link-file` буде вказано, що це посилання, яке вказує на `main-file`.
    *   `ln -s . link-dir`: створює символічне посилання на поточну директорію (`.`).

### **4. "Жорсткі" посилання**
*   **Команди:**
    ```bash
    ln main-file hardlink-file
    ls -li main-file hardlink-file
    ln lab-files hardlink-dir 
    ```
*   **Пояснення:**
    *   `ln` (без `-s`): створює жорстке посилання.
    *   `ls -li`: Ви побачите, що `main-file` і `hardlink-file` мають **однаковий** номер inode. Це два різних імені для одного і того ж файлу на диску.
    *   `ln lab-files hardlink-dir`: Ця команда завершиться з помилкою (`hard link not allowed for directory`). Жорсткі посилання не можна створювати для директорій.
*   **Висновки про відмінності:**
    *   **Символічне посилання:** Це окремий файл (з власним inode), який містить текстовий шлях до оригінального файлу. Може вказувати на файли/директорії в інших файлових системах. Якщо видалити оригінал, посилання стає "зламаним".
    *   **Жорстке посилання:** Це друге ім'я для того ж самого inode. Не може вказувати на директорії і не може виходити за межі однієї файлової системи. Файл фізично видаляється з диска лише тоді, коли видалено **останнє** жорстке посилання на нього.

### **5. Робота з вмістом файлу**
*   **Команди:**
    ```bash
    echo "string1" > main-file
    cat main-file
    echo "string2" >> main-file
    cat main-file
    echo "string3" >> link-file
    cat main-file
    echo "string4" >> hardlink-file
    cat main-file
    ```
*   **Пояснення:**
    *   `>`: Перенаправляє вивід, **перезаписуючи** вміст файлу.
    *   `>>`: Перенаправляє вивід, **дописуючи** в кінець файлу.
*   **Висновок про запис даних:**
    Незалежно від того, чи звертаємося ми до файлу напряму (`main-file`), через символічне посилання (`link-file`) чи через жорстке посилання (`hardlink-file`), всі зміни відбуваються в одному й тому ж місці на диску (в одному inode). Всі посилання ведуть до одного вмісту.
*   **Вивід першого та останнього рядка:**
    ```bash
    head -n 1 main-file
    tail -n 1 main-file
    ```

### **6. Інтерактивний перегляд (Термінал 2)**
*   **Команда:**
    ```bash
    tail -f link-file
    ```
*   **Пояснення:**
    *   `tail -f` (`--follow`): виводить останні рядки файлу і "зависає", очікуючи на додавання нових рядків, щоб одразу їх вивести. Це дуже зручно для моніторингу лог-файлів у реальному часі.

### **7. Динамічне оновлення**
*   **Дії:**
    1.  **В Терміналі 1:**
        ```bash
        echo "string5" >> hardlink-file
        ```
    2.  **В Терміналі 2:** Ви миттєво побачите, як з'явився рядок `string5`.
*   **Пояснення:**
    Це демонструє, що ядро системи повідомляє всім процесам, що "слухають" файл, про його зміну, і `tail -f` одразу зчитує та виводить новий вміст.

### **8. Пошук інформації**
*   **Знайти опцію read-only в `man mount`:**
    ```bash
    man mount | grep "read-only"
    ```
    (Ви знайдете опцію `ro`)
*   **Знайти опцію no access time:**
    ```bash
    man mount | grep "access" | grep "time"
    ```
    (Ви знайдете опцію `noatime`)
*   **Знайти файли з "host" в імені в /etc/:**
    ```bash
    find /etc -maxdepth 1 -iname "*host*"
    ```
    *   `-maxdepth 1`: шукати тільки в самій директорії `/etc`, без підкаталогів.
    *   `-iname`: пошук без урахування регістру.
*   **Знайти файли, що містять "127.0.0.1" в /etc/:**
    ```bash
    grep -r "127.0.0.1" /etc/
    ```
    *   `grep -r`: рекурсивний пошук по вмісту файлів.

### **9. Пошук файлів за типом**
*   **Знайти картинки і зберегти список:**
    ```bash
    find / -type f \( -name "*.jpg" -o -name "*.png" \) > pics-file 2>/dev/null
    ```
    *   `2>/dev/null`: ігнорувати помилки доступу.
*   **Переглянути метаінформацію:**
    ```bash
    stat "$(head -n 1 pics-file)"
    ```
*   **Знайти архіви і зберегти список:**
    ```bash
    find / -type f \( -name "*.zip" -o -name "*.gz" \) > arch-file 2>/dev/null
    ```
*   **Знайти файли користувача і відсортувати:**
    ```bash
    find / -type f -user $(whoami) > my-files 2>/dev/null
    sort my-files -o my-files
    ```
    *   `sort -o my-files`: відсортувати файл і записати результат у той самий файл.

### **10. Пошук файлів за розміром**
*   **Файли більше 20МБ:**
    ```bash
    find / -type f -size +20M
    ```
*   **Перенаправлення помилок:**
    ```bash
    find / -type f -size +20M 2> find.err
    ```
*   **Топ-5 найбільших файлів:**
    ```bash
    find / -type f -exec du -h {} + | sort -rh | head -n 5 > find.log
    ```
    *   `find ... -exec du -h {} +`: для всіх знайдених файлів виконати `du -h` (показати розмір у зручному форматі).
    *   `sort -rh`: відсортувати за числовим значенням (`-h`) у зворотному порядку (`-r`).
*   **Файли, що не займають місця:**
    ```bash
    find / -type f -size 0
    ```

### **Додатково**
*   **Перенаправити stdout і stderr в один файл:**
    ```bash
    find / -size +20M &> find.full_log
    ```
    *   `&>`: це скорочення в `bash` для `> find.full_log 2>&1`.
*   **Запуск від іншого користувача з перенаправленням:**
    *   **Дія:** Потрібно залогінитись як користувач `padavan` (`su - padavan`) і виконати:
        ```bash
        find / -size +20M > /root/find.log 2> /root/find.err
        ```
    *   **Результат:** Обидві команди перенаправлення зазнають невдачі з помилкою `Permission denied`.
    *   **Пояснення:** Звичайний користувач (`padavan`) не має прав на запис у домашню директорію суперкористувача (`/root`), яка захищена з міркувань безпеки.