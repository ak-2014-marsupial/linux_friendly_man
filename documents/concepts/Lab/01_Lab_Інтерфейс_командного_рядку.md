
### **Робота з консолью**

**1. Залогінитися на консоль VirtualBox (Alt+F2).**
*   **Пояснення:** Це фізична дія. На вікні віртуальної машини VirtualBox потрібно натиснути комбінацію клавіш `Правий Ctrl + F2` (або `Alt+F2`, залежно від налаштувань). Це перемкне вас на другу віртуальну консоль (tty2), де ви побачите запрошення для входу (`login:`). Ви можете використовувати `Alt+F1` по `Alt+F6` для перемикання між різними консолями.

**2. Залогінитися віддалено (ssh, putty).**
*   **Пояснення:** Для цього потрібно знати IP-адресу вашої віртуальної машини (можна дізнатися командою `ip a`).
    *   **З Windows:** Використовуйте програму PuTTY. Введіть IP-адресу в поле "Host Name (or IP address)" і натисніть "Open".
    *   **З Linux/macOS:** Відкрийте термінал і введіть команду `ssh ім'я_користувача@ip_адреса_машини`.
    Наприклад: `ssh user@192.168.1.10`.

**3. Переглянути консолі командою who (w).**
*   **Команди:**
    ```bash
    who
    w
    ```
*   **Пояснення:**
    *   `who`: Показує, хто з користувачів увійшов у систему, з якої консолі (наприклад, `tty2` для локального входу, `pts/0` для віддаленого SSH) та час входу.
    *   `w`: Надає більш детальну інформацію, ніж `who`, включаючи час простою користувача та команду, яку він зараз виконує.

---

### **Налаштування оболонки bash**

**1. Змінити привітання bash (prompt) на довільний.**
*   **Команда:**
    ```bash
    PS1="MyLab-> "
    ```
*   **Пояснення:** `PS1` — це спеціальна змінна середовища в `bash`, яка визначає вигляд основного запрошення командного рядка. Змінивши її значення, ви миттєво змінюєте вигляд запрошення для поточної сесії.

**2. Запустити програми ls, passwd, adduser, звернути увагу на їх вивід і працездатність.**
*   **Пояснення:**
    *   `ls`: Виведе список файлів у поточній директорії. Програма відпрацює і завершиться.
    *   `passwd`: Запустить інтерактивну програму для зміни пароля. Вона запитає старий і новий паролі. Якщо ви не root, вона, ймовірно, видасть помилку, але сама програма запуститься.
    *   `adduser`: Це програма для додавання користувачів, яка вимагає прав адміністратора (root). При запуску від звичайного користувача вона видасть помилку "Permission denied" і завершиться.
    *   Щоб перервати роботу інтерактивної програми, як `passwd`, натисніть `Ctrl+C`.

**3. Змінити шляхи пошуку програм на лише /sbin.**
*   **Команда:**
    ```bash
    export PATH="/sbin"
    ```
*   **Пояснення:** `PATH` — це змінна середовища, що містить перелік директорій, розділених двокрапкою, в яких оболонка шукає виконувані файли. Ця команда перезаписує `PATH`, залишаючи в ньому лише один шлях: `/sbin`.

**3.1. Повторити п. 2 і подивитися чи будуть відмінності у запуску цих програм. Якщо є, то чому вони виникли і як впливає на це PATH?**
*   **Результат:**
    *   `ls`: Не запуститься. Ви отримаєте помилку `bash: ls: command not found`.
    *   `passwd`: Не запуститься (`command not found`).
    *   `adduser`: Може запуститися, якщо виконуваний файл знаходиться в `/sbin` (що часто буває).
*   **Пояснення:** Відмінності виникли тому, що ми кардинально змінили змінну `PATH`. Тепер оболонка шукає програми **тільки** в директорії `/sbin`. Програма `ls` знаходиться в `/bin`, а `passwd` — в `/usr/bin`, тому оболонка їх не знаходить. `PATH` безпосередньо вказує, де шукати команди. Якщо шлях до програми не вказаний в `PATH`, її неможливо запустити за простою назвою.

**3.2. Спробувати запустити програми за їх абсолютним шляхом (/bin/ls, ...). Зробити висновок як повний шлях до програми впливає на її запуск.**
*   **Команда:**
    ```bash
    /bin/ls
    ```
*   **Результат:** Команда `ls` успішно виконається.
*   **Висновок:** Вказання повного (абсолютного) шляху до програми (`/bin/ls`) дозволяє запустити її незалежно від значення змінної `PATH`. Оболонка не шукає файл, а виконує його за вказаним шляхом напряму.

**Вийти з оболонки і зайти наново.**
*   **Команда:**
    ```bash
    exit
    ```
*   **Пояснення:** Після виходу і нового входу в систему всі тимчасові зміни (як `PS1` і `PATH`) будуть скинуті до значень за замовчуванням, які завантажуються з конфігураційних файлів.

---

### **Робота з псевдонімами команд**

**1. Додати аліас для перевизначення команди ls.**
*   **Команда:**
    ```bash
    alias ls='ls -laF'
    ```
*   **Пояснення:** `alias` створює псевдонім. Тепер щоразу, коли ви вводите `ls`, оболонка автоматично замінює його на `ls -laF` перед виконанням.

**2. Перевірити результат виводу команди ls та /bin/ls. Зробити висновок в чому різниця запуску программи і аліасу.**
*   **Результат:**
    *   `ls`: Виведе детальний список файлів (`-l`), включаючи приховані (`-a`), і класифікує їх (`-F`).
    *   `/bin/ls`: Виведе стандартний, короткий список файлів.
*   **Висновок:** Аліас — це підстановка на рівні оболонки. Коли ви викликаєте `ls`, спрацьовує аліас. Коли ви викликаєте програму за її повним шляхом (`/bin/ls`), ви звертаєтеся до виконуваного файлу напряму, ігноруючи аліас.

**3. Перезапустити оболонку (достатньо запустити bash ще раз), перевірити роботу та наявність alias-ів. Як довго існує псевдонім команди?**
*   **Команди:**
    ```bash
    bash
    alias
    ```
*   **Результат:** Після запуску нового екземпляру `bash`, команда `alias` не покаже вашого псевдоніма для `ls`.
*   **Висновок:** Псевдонім, створений у командному рядку, існує **лише в межах поточної сесії оболонки**. Він не успадковується дочірніми процесами і зникає після закриття сесії.

**4. Повернутися в попередню оболонку (exit, ctrl+d). Перевірити роботу та наявність alias-ів. Чи змінилися псевдоніми команд в батьківській оболонці bash?**
*   **Команди:**
    ```bash
    exit
    alias
    ```
*   **Результат:** Після повернення в батьківську оболонку, аліас для `ls` знову буде присутній.
*   **Висновок:** Зміни в дочірній оболонці (включаючи видалення або відсутність аліасів) **не впливають** на батьківську оболонку.

**5. Дописати створення ще одного alias-у в кінці файлу .bashrc. Перевірити роботу та наявність alias. Чи існує alias після збереження файлу?**
*   **Команда:**
    ```bash
    echo "alias e='echo New alias'" >> ~/.bashrc
    ```
*   **Результат:** Одразу після виконання цієї команди, якщо ви введете `e` або `alias`, нового псевдоніма не буде.
*   **Висновок:** Псевдонім **не існує** одразу після збереження файлу. Файл `.bashrc` зчитується лише під час запуску нової інтерактивної оболонки.

**5. (повтор) Перезапустити оболонку, перевірити роботу та наявність alias. Чи існує alias після перезапуску bash? Чому?**
*   **Команди:**
    ```bash
    bash
    e
    ```
*   **Результат:** Тепер команда `e` працює і виводить "New alias".
*   **Висновок:** Аліас **існує** після перезапуску. Тому що нова оболонка `bash` при старті виконує команди з файлу `~/.bashrc`, де і був визначений наш новий аліас.

**6. Прибрати нещодавно створений alias (команда unalias). Перевірити роботу та наявність alias. Чи зявиться alias після перезапуску bash?**
*   **Команди:**
    ```bash
    unalias e
    # Перевірка: e -> command not found
    bash
    # Перевірка в новій оболонці:
    e 
    ```
*   **Результат:** `unalias e` видаляє псевдонім для поточної сесії. Але після перезапуску `bash` він з'явиться знову.
*   **Висновок:** `unalias` діє лише на поточну сесію. Щоб видалити аліас назавжди, потрібно видалити відповідний рядок з файлу `~/.bashrc`.

---

### **\* Завдання із зірочкою**

**Зробіть так, щоб при переході в нову директорію спочатку виводилось повідомлення, а потім відбувався перехід і виводився повний шлях.**

*   **Рішення:**
    Для цього потрібно створити функцію з назвою `cd` і додати її у ваш файл `~/.bashrc`, щоб вона була доступна завжди.

    1.  Відкрийте файл `~/.bashrc` у текстовому редакторі (наприклад, `nano ~/.bashrc`).
    2.  Додайте в кінець файлу наступні рядки:

    ```bash
    cd() {
        echo "We are going to change directory to $1"
        builtin cd "$@"
        pwd
    }
    ```
    3.  Збережіть файл і перезапустіть оболонку (або виконайте `source ~/.bashrc`).

*   **Пояснення:**
    *   `cd() { ... }`: Ми створюємо функцію з іменем `cd`, яка "перехоплює" стандартну команду.
    *   `echo "We are going to change directory to $1"`: Виводимо повідомлення. `$1` — це перший аргумент, переданий команді (назва директорії).
    *   `builtin cd "$@"`: Це найважливіша частина. `builtin cd` викликає **вбудовану** команду `cd`, а не нашу функцію (інакше була б нескінченна рекурсія). `"$@"` передає всі оригінальні аргументи команді `cd`, щоб зберегти її повну функціональність (наприклад, `cd -` для повернення назад).
    *   `pwd`: Після успішного переходу в директорію, ця команда виводить поточний абсолютний шлях.
