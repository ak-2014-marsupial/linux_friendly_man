### **Завдання 1: Пошук IP та MAC адрес**

> Напишіть сценарій, який в якості вхідного параметру приймає шлях до каталогу і виконує пошук IP-адрес в усіх текстових файлах, які він містить.
> Результат має бути виведений на екран і продубльований в файл IP.log.
> При вживанні додаткової опції "--mac" має відбуватися пошук не IP-адрес, а MAC-адрес. При цьому результат має дублюватися вже в файл MAC.log.

**Рішення:**

```bash
#!/bin/bash
# Скрипт для пошуку IP або MAC-адрес у файлах вказаного каталогу.

# Перевірка наявності аргументів.
: "${1:?Error: Directory path is missing. Usage: $0 [--mac] <directory_path>}"

# Ініціалізація змінних
TARGET_DIR=""
REGEX=""
LOG_FILE=""
GREP_FLAG="" # Змінна для прапора grep (-E або -P)

# Обробка аргументів, визначення конфігурації за допомогою case
case "$1" in
    "--mac")
        # Перевірка шляху до каталогу після опції --mac.
        TARGET_DIR="${2:?Error: Directory path missing after --mac option. Usage: $0 --mac <directory_path>}"
        
        # Конфігурація для MAC
        REGEX='(?<=[^-:\w]|^)([\da-f]{2}[:-]){5}([\da-f]{2})(?=[^-:\w]|$)'
        LOG_FILE="MAC.log"
        GREP_FLAG="-P" # Perl-сумісні регулярні вирази
        ;;
    *)
        # Конфігурація для IP (за замовчуванням)
        TARGET_DIR="$1"
        REGEX='\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b'
        LOG_FILE="IP.log"
        GREP_FLAG="-E" # Розширені регулярні вирази
        ;;
esac

# Перевірка існування каталогу
if [ ! -d "$TARGET_DIR" ]; then
    echo "Error: Directory not found: '$TARGET_DIR'"
    exit 1
fi

# --- Search Execution (Using recursive grep) ---

echo "Searching for '$GREP_FLAG' addresses in directory '$TARGET_DIR'..."

# Очищення файлу логу перед новим пошуком
> "$LOG_FILE"

# Пошук за допомогою рекурсивного grep:
# -r: рекурсивний пошук у каталозі
# -I: ігнорувати бінарні файли
# -H: друкувати ім'я файлу
# -n: друкувати номер рядка
# -o: виводити тільки збіг
# $GREP_FLAG: динамічно встановлює -E або -P
# tee: дублює вивід (-a: дописувати в файл)

grep -rIHno "$GREP_FLAG" "$REGEX" "$TARGET_DIR" 2>&1 | tee -a "$LOG_FILE"

# Перевірка, чи grep завершився з помилкою (окрім кодів 0 і 1)
# PIPESTATUS[0] - це код виходу grep. Код 1 означає "не знайдено збігів" і не є помилкою.
if [ ${PIPESTATUS[0]} -ne 0 ] && [ ${PIPESTATUS[0]} -ne 1 ]; then
    echo "Warning: Grep search exited with an error. Check file permissions or path validity."
fi

echo "Search completed. Results saved to file '$LOG_FILE'."
```

**Пояснення:**
1.  Сценарій перевіряє, чи були надані аргументи.
2.  Він аналізує перший аргумент: якщо це `--mac`, режим пошуку змінюється на "mac", а цільовим каталогом вважається другий аргумент. В іншому випадку, режим — "ip", а каталог — перший аргумент.
3.  Виконується перевірка, чи існує вказаний каталог.
4.  Залежно від режиму, встановлюється відповідний регулярний вираз (`REGEX`) та ім'я лог-файлу (`LOG_FILE`).
5.  Для кожного файлу викликається `grep` з відповідним регулярним виразом для пошуку IP або MAC адрес.
6.  Результат роботи `grep` (ім'я файлу, номер рядка та знайдена адреса) виводиться на екран та одночасно дописується у відповідний лог-файл за допомогою команди `tee -a`.

---


### **Завдання 2: Ротація логів процесів**

> Написати сценарій, який раз в 10 сек перевіряє перелік запущених процесів і дописує цю інформацію в файл PS.log. Через кожні 5 ітерацій має відбуватися ротація журналу - поточний файл PS.log має стискуватися gzip-ом (файл PS.log1.gz). В системі має залишатися не більше 5 стиснених журналів (PS.log1.gz, PS.log2.gz, ...).
> Примітка: використовувати утіліту logrotate не можна.

**Рішення:**

```bash
#!/bin/bash

LOG_FILE="PS.log"
MAX_ROTATED_LOGS=5
ITERATION_COUNT=0
LOGS_PER_ROTATION=5

# Нескінченний цикл
while true; do
    # Дописуємо поточний список процесів з датою в лог
    echo "--- Log entry at $(date) ---" >> "$LOG_FILE"
    ps aux >> "$LOG_FILE"
    
    # Збільшуємо лічильник ітерацій
    ((ITERATION_COUNT++))
    
    # Перевіряємо, чи настав час для ротації
    if [ $((ITERATION_COUNT % LOGS_PER_ROTATION)) -eq 0 ]; then
        echo "--- Rotating logs ---"
        
        # 1. Видаляємо найстаріший архів, якщо він існує
        if [ -f "${LOG_FILE}${MAX_ROTATED_LOGS}.gz" ]; then
            rm "${LOG_FILE}${MAX_ROTATED_LOGS}.gz"
        fi
        
        # 2. Зміщуємо номери всіх існуючих архівів
        for i in $(seq $((MAX_ROTATED_LOGS - 1)) -1 1); do
            if [ -f "${LOG_FILE}${i}.gz" ]; then
                mv "${LOG_FILE}${i}.gz" "${LOG_FILE}$((i + 1)).gz"
            fi
        done
        
        # 3. Архівуємо поточний лог-файл
        if [ -f "$LOG_FILE" ]; then
            gzip -c "$LOG_FILE" > "${LOG_FILE}1.gz"
            # 4. Очищуємо поточний лог-файл
            > "$LOG_FILE"
        fi
        
        echo "--- Rotation complete ---"
    fi
    
    # Чекаємо 10 секунд до наступної ітерації
    sleep 10
done
```

**Пояснення:**
1.  Сценарій працює у нескінченному циклі `while true`.
2.  Кожні 10 секунд він дописує вивід команди `ps aux` у файл `PS.log`.
3.  Змінна `ITERATION_COUNT` відстежує кількість записів.
4.  Коли лічильник стає кратним 5 (`$((ITERATION_COUNT % LOGS_PER_ROTATION)) -eq 0`), запускається механізм ротації:
    *   Спочатку видаляється найстаріший архів (`PS.log5.gz`), якщо він існує.
    *   Потім всі архіви перейменовуються по черзі: `PS.log4.gz` стає `PS.log5.gz`, `PS.log3.gz` стає `PS.log4.gz` і так далі.
    *   Поточний файл `PS.log` стискається в `PS.log1.gz`.
    *   Після успішного стиснення `PS.log` очищується (`> "$LOG_FILE"`) для нових записів.

---


### **Завдання 3: Фоновий моніторинг процесів**

> Напишіть простий сценарій ps.sh, який кожну секунду перевіряє перелік усіх запущених процесів і дописує його в файл /var/log/PS.log. Сценарій має працювати в фоновому режимі.

**Рішення (файл `ps.sh`):**

```bash
#!/bin/bash

LOG_FILE="/var/log/PS.log"

# Перевірка прав на запис в /var/log
if [ ! -w "$(dirname "$LOG_FILE")" ]; then
    echo "Помилка: Немає прав на запис у каталог $(dirname "$LOG_FILE"). Запустіть з sudo."
    exit 1
fi

while true; do
    # Дописуємо дату та список процесів
    date >> "$LOG_FILE"
    ps aux >> "$LOG_FILE"
    # Чекаємо 1 секунду
    sleep 1
done
```

**Пояснення:**
1.  Сценарій визначає шлях до лог-файлу `/var/log/PS.log`. Оскільки цей каталог зазвичай вимагає прав адміністратора, скрипт перевіряє наявність прав на запис і виводить помилку, якщо їх немає.
2.  У нескінченному циклі `while true` він кожну секунду дописує поточну дату та вивід `ps aux` у лог-файл.
3.  Щоб запустити його у фоновому режимі, потрібно виконати в терміналі:
    ```bash
    sudo bash ps.sh &
    ```
    Символ `&` в кінці команди вказує оболонці запустити процес у фоні.

---


### **Завдання 4: Топ 10 процесів по пам'яті**

> Вивести топ 10 процесів по використанню пам'яті (поле RSS із ps).

**Рішення:**

```bash
ps -eo pid,user,rss,comm --sort=-rss | head -n 11
```

**Пояснення:**
*   `ps -eo pid,user,rss,comm`: Команда `ps` з опцією `-e` (показати всі процеси) та `-o` (задати формат виводу). Ми просимо вивести `pid` (ID процесу), `user` (користувач), `rss` (Resident Set Size - фізична пам'ять, яку займає процес, в кілобайтах) та `comm` (назва команди).
*   `--sort=-rss`: Сортувати вивід за колонкою `rss`. Знак мінус (`-`) означає сортування у зворотному (спадному) порядку.
*   `| head -n 11`: Передати результат сортування команді `head`, яка залишить тільки перші 11 рядків (1 рядок заголовків + 10 рядків процесів).

---


### **Завдання 5: "Вбивця" процесів по пам'яті**

> Написати сценарій, який періодично перевіряє систему і відправляє сигнал TERM тим процесам, які використовують пам'яті більше заданого N.

**Рішення:**

```bash
#!/bin/bash

# Ліміт пам'яті в КІЛОБАЙТАХ.
# Наприклад, 102400 KB = 100 MB
MEMORY_LIMIT_KB=$1

if [ -z "$MEMORY_LIMIT_KB" ]; then
    echo "Помилка: не задано ліміт пам'яті в КБ."
    echo "Використання: $0 <ліміт_в_кб>"
    exit 1
fi

echo "Запущено моніторинг. Ліміт пам'яті: $MEMORY_LIMIT_KB КБ."

while true; do
    # Знаходимо процеси, що перевищують ліміт
    # ps -eo pid,rss --no-headers: вивести PID та RSS без заголовків
    # awk ...: для кожного рядка, якщо другий стовпець (RSS) більший за ліміт, друкувати перший (PID)
    pids_to_kill=$(ps -eo pid,rss --no-headers | awk -v limit="$MEMORY_LIMIT_KB" 
'$2 > limit {print $1}')

    if [ -n "$pids_to_kill" ]; then
        echo "$(date): Знайдено процеси, що перевищують ліміт: $pids_to_kill. Надсилається SIGTERM..."
        # Надсилаємо сигнал TERM знайденим процесам
        kill -15 $pids_to_kill
    fi
    
    # Перевіряти кожні 30 секунд
    sleep 30
done
```

**Пояснення:**
1.  Сценарій приймає перший аргумент командного рядка як ліміт пам'яті в кілобайтах.
2.  У нескінченному циклі він виконує перевірку кожні 30 секунд.
3.  Команда `ps -eo pid,rss --no-headers` виводить список всіх процесів, показуючи лише їх PID та використання пам'яті (RSS) без заголовків.
4.  Цей список передається `awk`. `awk` порівнює значення другого стовпця (`$2`, тобто RSS) із заданим лімітом. Якщо ліміт перевищено, `awk` друкує PID процесу (`$1`).
5.  Список отриманих PID зберігається у змінній `pids_to_kill`.
6.  Якщо список не порожній, команда `kill -15` (сигнал `TERM`) відправляє запит на завершення роботи кожному процесу з цього списку.

---


### **Завдання 6: Статистика по розширеннях файлів**

> Вивести перелік усіх розширень файлів і кількість файлів з таким розширенням у вказаному каталозі і всіх його підкаталогах.
> Формат виводу: <розширення> - <кількість файлів>

**Рішення:**

```bash
#!/bin/bash

TARGET_DIR=${1:-.} # Використовувати перший аргумент або поточний каталог

if [ ! -d "$TARGET_DIR" ]; then
    echo "Помилка: Каталог '$TARGET_DIR' не знайдено."
    exit 1
fi

echo "Статистика розширень для каталогу '$TARGET_DIR':"

find "$TARGET_DIR" -type f -name "*.*" |
sed -n 's/.*\.\([^.]*\)$/\1/p' |
tr '[:upper:]' '[:lower:]' |
sort |
unix -c |
sort -nr |
awk '{print "."$2 " - " $1}'
```

**Пояснення:**
Це ланцюжок команд, де результат попередньої передається наступній:
1.  `find "$TARGET_DIR" -type f -name "*.*"`: Знаходить всі файли (`-type f`), що містять крапку в імені, у вказаному каталозі та підкаталогах.
2.  `sed -n 's/.*\.\([^.]*\)$/\1/p'`: Для кожного знайденого шляху витягує тільки частину після останньої крапки (тобто розширення).
3.  `tr '[:upper:]' '[:lower:]'`: Переводить всі розширення в нижній регістр, щоб `.JPG` та `.jpg` вважалися однаковими.
4.  `sort`: Сортує список розширень за алфавітом. Це необхідно для роботи `uniq`.
5.  `uniq -c`: Підраховує кількість кожного унікального розширення в списку. Вивід має формат `кількість розширення`.
6.  `sort -nr`: Сортує результат за кількістю (`-n` — числове сортування, `-r` — у зворотному порядку).
7.  `awk '{print "."$2 " - " $1}'`: Форматує фінальний вивід у потрібний вигляд `<розширення> - <кількість файлів>`.

---


### **Опціонально 1: `top`-like статистика**

> Створити сценарій bash, який виводить загальну статистику по використанню ресурсів системи за аналогією як це робить утиліта top (в шапці виводу). Дані мають оновлюватися раз на секунду і переписувати поверх попередній вивід.

**Рішення:**

```bash
#!/bin/bash

while true; do
    # Очистити екран
    clear
    
    # 1. Uptime і Load Average
    uptime_info=$(uptime -p)
    load_avg=$(uptime | awk -F'[a-z]*: ' '{print $2}')
    
    # 2. Завдання (Processes)
    total_tasks=$(ps -e --no-headers | wc -l)
    running_tasks=$(ps -e --no-headers -o state | grep -c "R")
    
    # 3. Пам'ять (з free)
    mem_info=$(free -m | grep Mem)
    mem_total=$(echo $mem_info | awk '{print $2}')
    mem_used=$(echo $mem_info | awk '{print $3}')
    mem_free=$(echo $mem_info | awk '{print $4}')
    
    # 4. Swap (з free)
    swap_info=$(free -m | grep Swap)
    swap_total=$(echo $swap_info | awk '{print $2}')
    swap_used=$(echo $swap_info | awk '{print $3}')
    swap_free=$(echo $swap_info | awk '{print $4}')

    # Вивід інформації
    echo "--- System Stats $(date) ---"
    echo "Uptime: ${uptime_info#up }"
    echo "Load Average: $load_avg"
    echo "Tasks: $total_tasks total, $running_tasks running"
    echo "Memory (MB): Total: $mem_total, Used: $mem_used, Free: $mem_free"
    echo "Swap (MB):   Total: $swap_total, Used: $swap_used, Free: $swap_free"
    
    # Оновлення раз на секунду
    sleep 1
done
```

**Пояснення:**
1.  Сценарій працює в нескінченному циклі. На початку кожної ітерації команда `clear` очищує екран.
2.  `uptime`: Використовується для отримання часу роботи системи (`-p` для "красивого" формату) та середнього навантаження (`load average`).
3.  `ps`: Використовується для підрахунку загальної кількості процесів та кількості процесів у стані "Running" (`R`).
4.  `free -m`: Надає інформацію про використання фізичної пам'яті (RAM) та файлу підкачки (swap) в мегабайтах.
5.  `awk` та інші утиліти використовуються для "вирізання" потрібних значень з виводу системних команд.
6.  В кінці циклу `sleep 1` робить паузу на одну секунду.

---


### **Опціонально 2: Розширення `top`-like статистики**

> Розширити функціонал раніше створеного сценарію - окрім статистики виводити топ 10 процесів по обраному параметру. Параметри для вибору (сортування) - cpu, rss, pid.

**Рішення:**

```bash
#!/bin/bash

# За замовчуванням сортуємо по CPU
SORT_BY=${1:-cpu}

# Перевірка коректності параметра сортування
case "$SORT_BY" in
    cpu|rss|pid)
        # Все добре, продовжуємо
        ;;
    *)
        echo "Помилка: невірний параметр сортування. Доступні: cpu, rss, pid."
        exit 1
        ;;
esac

# Конвертація нашого параметра в ключ для ps
# %cpu для cpu, -rss для rss (спадний порядок)
SORT_KEY="-%cpu"
if [ "$SORT_BY" == "rss" ]; then
    SORT_KEY="-rss"
elif [ "$SORT_BY" == "pid" ]; then
    SORT_KEY="pid"
fi


while true; do
    # --- Початок блоку зі статистики (з попереднього завдання) ---
    clear
    uptime_info=$(uptime -p)
    load_avg=$(uptime | awk -F'[a-z]*: ' '{print $2}')
    total_tasks=$(ps -e --no-headers | wc -l)
    running_tasks=$(ps -e --no-headers -o state | grep -c "R")
    mem_info=$(free -m | grep Mem)
    mem_total=$(echo $mem_info | awk '{print $2}')
    mem_used=$(echo $mem_info | awk '{print $3}')
    mem_free=$(echo $mem_info | awk '{print $4}')
    swap_info=$(free -m | grep Swap)
    swap_total=$(echo $swap_info | awk '{print $2}')
    swap_used=$(echo $swap_info | awk '{print $3}')
    swap_free=$(echo $swap_info | awk '{print $4}')

    echo "--- System Stats $(date) ---"
    echo "Uptime: ${uptime_info#up }"
    echo "Load Average: $load_avg"
    echo "Tasks: $total_tasks total, $running_tasks running"
    echo "Memory (MB): Total: $mem_total, Used: $mem_used, Free: $mem_free"
    echo "Swap (MB):   Total: $swap_total, Used: $swap_used, Free: $swap_free"
    # --- Кінець блоку зі статистики ---

    echo
    echo "--- Top 10 Processes (sorted by: $SORT_BY) ---"
    
    # Вивід топ 10 процесів з сортуванням
    ps -eo pid,user,%cpu,rss,comm --sort=$SORT_KEY | head -n 11

    sleep 1
done
```

**Пояснення:**
1.  Сценарій приймає один опціональний аргумент: `cpu`, `rss` або `pid`. Якщо аргумент не надано, за замовчуванням використовується `cpu`.
2.  `case` перевіряє, чи є наданий аргумент коректним.
3.  Змінна `SORT_KEY` формується для команди `ps`. Для `cpu` та `rss` потрібне сортування у спадному порядку (знак `-`), для `pid` — у зростаючому.
4.  Основний цикл залишається таким самим, як у попередньому завданні, але після виводу загальної статистики додається блок:
    *   Виводиться заголовок, що показує, за яким полем іде сортування.
    *   Команда `ps -eo pid,user,%cpu,rss,comm --sort=$SORT_KEY | head -n 11` виводить список 10 найбільш навантажених процесів відповідно до обраного критерію.
