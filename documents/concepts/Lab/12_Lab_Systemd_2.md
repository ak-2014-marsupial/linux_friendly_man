Налаштуйте систему так, щоб після її перезавантаження за замовченням був обраний однокористувацький режим.

Після перезавантаження та входу в систему виконати наступну команду: (bc***8)

systemctl list-units --type=target | grep $(systemctl get-default) | awk '{print $1 $2}' | md5sum | cut -c 5-10

---

### Відповідь

Щоб налаштувати систему для завантаження в однокористувацький режим (rescue mode) за замовчуванням, потрібно змінити стандартну ціль (target) для `systemd`.

**Команда:**

Для цього виконайте наступну команду:

```bash
sudo systemctl set-default rescue.target
```

**Пояснення:**

*   `sudo`: Ця команда виконується з правами суперкористувача, оскільки зміна конфігурації завантаження системи є адміністративною дією.
*   `systemctl`: Це основний інструмент для управління `systemd`.
*   `set-default rescue.target`: Ця частина команди встановлює `rescue.target` як ціль за замовчуванням. `rescue.target` відповідає за однокористувацький режим, в якому завантажується мінімальне оточення для відновлення системи.

Після виконання цієї команди буде створено символічне посилання `/etc/systemd/system/default.target`, яке вказуватиме на `/usr/lib/systemd/system/rescue.target`. При наступному перезавантаженні система автоматично завантажиться в однокористувацький режим.

Щоб повернутися до звичайного багатокористувацького графічного режиму, потрібно буде виконати:
```bash
sudo systemctl set-default graphical.target
```

---

### Пояснення можливих режимів (цілей/targets)

`systemd` використовує "цілі" (targets) для групування юнітів та визначення різних режимів роботи системи. Вони є аналогом рівнів виконання (runlevels) у старих системах ініціалізації, таких як SysV.

Ось основні цілі:

*   `poweroff.target` (runlevel 0): Вимикає систему.
*   `rescue.target` (runlevel 1): **Однокористувацький режим**. Завантажує базову систему з командним рядком, монтує файлові системи, але не запускає мережеві сервіси та інші служби. Використовується для відновлення системи.

#### Чому в режимі `rescue.target` не працює SSH?

Підключення через SSH неможливе в режимі `rescue.target` з наступних причин:

1.  **Мережеві служби вимкнені:** `rescue.target` завантажує лише мінімально необхідний набір служб для відновлення системи. Мережеві служби, включаючи `sshd` (SSH daemon), до цього набору не входять і не запускаються автоматично.
2.  **Призначення режиму:** Цей режим призначений для локального відновлення системи, коли можуть бути проблеми з конфігурацією мережі або іншими системними службами. Запуск мережевих сервісів може перешкодити діагностиці або створити загрозу безпеці, якщо система скомпрометована.

Отже, оскільки служба SSH не запущена, сервер не приймає вхідні з'єднання на 22-му порту, і підключитися до нього віддалено неможливо. Для доступу до системи в цьому режимі потрібен прямий фізичний доступ до консолі (або через віртуальну консоль хмарного провайдера).
*   `multi-user.target` (runlevels 2, 3, 4): **Багатокористувацький режим без графічного інтерфейсу**. Запускає всі основні системні служби, включаючи мережу, але без графічної оболонки. Це стандартний режим для серверів.
*   `graphical.target` (runlevel 5): **Багатокористувацький режим з графічним інтерфейсом**. Запускає все, що є в `multi-user.target`, плюс графічний дисплейний менеджер та оболонку (GNOME, KDE тощо). Це стандартний режим для настільних комп'ютерів.
*   `reboot.target` (runlevel 6): Перезавантажує систему.

### Перезавантаження системи

Для перезавантаження системи можна скористатися наступною командою:

```bash
sudo systemctl reboot
```

Ця команда ініціює процес перезавантаження системи через `systemd`.

*   `emergency.target`: **Аварійний режим**. Завантажує мінімально можливе середовище, монтуючи кореневу файлову систему лише для читання. Використовується для виправлення серйозних проблем, коли навіть `rescue.target` не працює.

Ви можете перемикатися між цими режимами "на льоту" за допомогою команди `sudo systemctl isolate <назва_цілі>`. Наприклад, `sudo systemctl isolate multi-user.target` перемкне систему в текстовий режим без перезавантаження.

### Різниця між `isolate` та `set-default`

Важливо розуміти різницю між командами `isolate` та `set-default`:

*   `sudo systemctl set-default <назва_цілі>`: **Змінює ціль за замовчуванням на постійній основі.** Ця зміна зберігається після перезавантаження. Наприклад, якщо ви встановили `rescue.target` як ціль за замовчуванням, система завжди завантажуватиметься в однокористувацькому режимі.
*   `sudo systemctl isolate <назва_цілі>`: **Перемикає режим лише для поточної сесії.** Ця команда не впливає на ціль за замовчуванням.

**Приклад:**

Якщо ви виконали `sudo systemctl set-default rescue.target`, а потім `sudo systemctl isolate multi-user.target`:

1.  Ваша система перейде в багатокористувацький режим (`multi-user.target`) **без перезавантаження**.
2.  Однак, ціль за замовчуванням **залишиться `rescue.target`**.
3.  Після наступного перезавантаження система завантажиться в режим `rescue.target`.
---

### Завдання №2: Створення служби Systemd для моніторингу розміру каталогу

**Мета:** Налаштувати систему так, щоб вона за замовчуванням завантажувалася в багатокористувацький режим, і створити службу `systemd`, яка автоматично вимірює розмір каталогу `/var` при кожному завантаженні та записує результат у лог-файл.

**Умови:**

1.  Перейти в багатокористувацький режим роботи системи (`multi-user.target`).
2.  Повернути багатокористувацький режим як режим за замовчуванням.
3.  Створити службу `systemd` з ім'ям `varsize`.
4.  Служба повинна при кожному завантаженні в багатокористувацькому режимі:
    *   Підраховувати розмір каталогу `/var` в мегабайтах.
    *   Записувати отримане число з нового рядка в журнал `/root/varsize.log`.

---

### Пояснення по виконанню

Ось покрокова інструкція для виконання цього завдання.

#### Крок 1: Перехід та встановлення багатокористувацького режиму

Спочатку варто тимчасово перейти в багатокористувацький режим, щоб переконатися, що все працює як слід, а вже потім встановлювати його як режим за замовчуванням. Це безпечніший підхід.

**1. Перейдіть в багатокористувацький режим (для поточної сесії):**
Ця команда негайно перемкне систему в `multi-user.target` без перезавантаження.

**Команда:**
```bash
sudo systemctl isolate multi-user.target
```

**2. Встановіть багатокористувацький режим як стандартний:**
Після того, як ви переконалися, що система працює коректно, зробіть цей режим постійним для майбутніх завантажень.

**Команда:**
```bash
sudo systemctl set-default multi-user.target
```

**Пояснення:**
*   `isolate`: змінює режим роботи системи **тимчасово**, до наступного перезавантаження.
*   `set-default`: змінює режим роботи системи **на постійній основі**, зберігаючи вибір після перезавантаження.

#### Крок 2: Створення файлу служби (Unit-файлу)

Вам потрібно створити файл, який описує, що і коли повинна робити ваша служба.

**1. Створіть файл `varsize.service`:**

```bash
sudo nano /etc/systemd/system/varsize.service
```

**2. Додайте в нього наступний вміст:**

```ini
[Unit]
Description=Calculate /var directory size at boot

[Service]
Type=oneshot
ExecStart=/bin/bash -c "du -sm /var | cut -f1 >> /root/varsize.log"

[Install]
WantedBy=multi-user.target
```

***Примітка щодо прав доступу:*** *Сам файл `varsize.service` не потребує прав на виконання (`+x`). Це конфігураційний файл, який читає процес `systemd`. Командою, яка фактично виконується, є `/bin/bash` (вказана в `ExecStart=`), і ця програма вже має необхідні права на виконання.*

**Пояснення вмісту файлу:**

*   **`[Unit]`**:
    *   `Description`: Простий опис служби, який буде видно в статусі.

*   **`[Service]`**:
    *   `Type=oneshot`: Вказує, що це служба, яка виконує одну дію і завершується, а не працює постійно у фоні.
    *   `ExecStart`: Головна команда, яка буде виконана.
        *   `/bin/bash -c "..."`: Запускає оболонку `bash` для виконання команди в лапках. Це потрібно для коректної роботи перенаправлення (`>>`) та каналу (`|`).
        *   `du -sm /var`: Команда для підрахунку розміру (`du`) каталогу `/var`.
            *   `-s` (summarize) — показує загальний розмір, а не для кожного підкаталогу.
            *   `-m` (megabytes) — виводить результат у мегабайтах.
        *   `cut -f1`: Вирізає тільки перше поле (саме число) з виводу `du`.
        *   `>> /root/varsize.log`: **Додає** (не перезаписує) отримане число в кінець файлу `/root/varsize.log`.

*   **`[Install]`**:
    *   `WantedBy=multi-user.target`: Це найважливіша частина. Вона вказує, що ця служба є "бажаною" для цілі `multi-user.target`. Коли ви "вмикаєте" (enable) службу, `systemd` створює посилання, яке змушує запускати `varsize.service` щоразу, коли система входить у режим `multi-user.target` (тобто під час завантаження).

#### Крок 3: Активація та перевірка служби

Після створення файлу служби потрібно повідомити `systemd` про зміни та активувати її.

**1. Перезавантажте конфігурацію `systemd`:**
`systemd` кешує unit-файли, тому після створення нового файлу потрібно оновити кеш.

```bash
sudo systemctl daemon-reload
```

**2. Увімкніть службу:**
Ця команда створює символічне посилання, яке прив'язує службу до `multi-user.target`, щоб вона запускалася автоматично при завантаженні.

```bash
sudo systemctl enable varsize.service
```

**3. Перевірте роботу служби (необов'язково, але рекомендовано):**
Ви можете запустити службу вручну, щоб перевірити, чи вона працює коректно, не перезавантажуючи комп'ютер.

```bash
sudo systemctl start varsize.service
```

Після цього перевірте вміст лог-файлу. Оскільки файл `varsize.log` створюється в домашньому каталозі користувача `root` (`/root`), для доступу до нього потрібні права суперкористувача.

**Спосіб 1: Використання `sudo` (рекомендовано)**
Ви можете виконати одну команду з правами `root`:
```bash
sudo cat /root/varsize.log
```

**Спосіб 2: Перехід до користувача `root`**
Як ви й зазначили, можна повністю перейти в сесію користувача `root` за допомогою команди `sudo su -` (або `su -`, якщо для `root` встановлено пароль):
```bash
sudo su -
```
Після цього ви опинитеся в оболонці `root` і зможете переглянути файл простою командою:
```bash
cat /root/varsize.log
```
Щоб вийти з сесії `root`, введіть `exit`.

В обох випадках ви повинні побачити в файлі один рядок з числом — розміром `/var` в мегабайтах. Після перезавантаження системи там з'явиться другий рядок.

---

### Фінальна перевірка (для самоконтролю)

Для повної перевірки правильності виконання завдання, як зазначено в умові, потрібно виконати спеціальну команду.

**Важливе зауваження:** Ця команда повинна виконуватися з правами суперкористувача, оскільки вона запускає служби (`systemctl start`) та шукає файли в системному каталозі `/root`.

Як ви правильно зазначили, найнадійніший спосіб — це спочатку отримати оболонку `root`:

```bash
sudo su -
```

І вже після цього виконати саму команду перевірки:

```bash
echo $(systemctl list-unit-files | grep varsize | awk '{print $1, $2}') $(systemctl start varsize 2>&1 && find /root -mmin -0.2 -type f 2>&1) | md5sum | cut -c 10-16
```

Ця команда комплексно перевіряє:
1.  Чи існує `varsize.service` і чи він увімкнений (`enabled`).
2.  Чи запускається служба без помилок.
3.  Чи створюється/модифікується файл у каталозі `/root` відразу після запуску служби.

Результатом її роботи має бути хеш-код, який відповідає очікуваному в завданні.

---

### Завдання №3: Створення власного Target

1.  Створіть свій target та дайте йому ім'я 'custom'.
2.  Згрупуйте в рамках custom свій сервіс varsize та сервіс sshd, попередньо прибравши їх із багатокористувацького target-у.
3.  При переході на цей target повинні підвантажуватися всі служби з багатокористувацького режиму. 
4.  Для перевірки результату активуйте новостворений target і виконайте команду: (16****e)

echo $(systemctl list-units --type=target | grep custom | awk '{print $1 $2 $3}') $(systemctl list-dependencies custom.target | head -3 | sed s/[^a-z]//g | sort) | md5sum | cut -c 10-16

---

### Пояснення по виконанню

Це завдання демонструє, як створювати власні групи служб та керувати залежностями між ними.

#### Крок 1: Створення файлу `custom.target`

`Target` в `systemd` — це просто unit-файл, який групує інші юніти. Ми створимо свій, який буде залежати від `multi-user.target`, фактично "успадковуючи" його.

**1. Створіть файл:**
```bash
sudo nano /etc/systemd/system/custom.target
```

**2. Додайте в нього наступний вміст:**
```ini
[Unit]
Description=Custom Target with varsize and sshd
Requires=multi-user.target
After=multi-user.target
Wants=varsize.service sshd.service
```

**Пояснення:**
*   `Description`: Опис нашого таргету.
*   `Requires=multi-user.target`: Встановлює жорстку залежність. `custom.target` не може бути запущений без успішного запуску `multi-user.target`.
*   `After=multi-user.target`: Гарантує, що `custom.target` буде запущений **після** того, як `multi-user.target` повністю активується. **Ці два рядки і є механізмом "успадкування"**.
*   `Wants=varsize.service sshd.service`: Це директива для слабких залежностей, яка працює **декларативно**.
    *   **Декларативний підхід**: Ви не даєте прямих команд "запустити сервіс". Ви лише описуєте бажаний стан: "Коли цей таргет активний, я хочу, щоб ці служби також працювали". `systemd` сам вирішує, як цього досягти.
    *   **Слабка залежність**: На відміну від `Requires`, якщо `varsize.service` або `sshd.service` не зможуть запуститися, це **не вплине** на успішний запуск `custom.target`. `systemd` просто зафіксує помилку для невдалої служби, але продовжить активацію таргету.
    *   **Зв'язок з `WantedBy`**: Директива `Wants=` в таргеті є "приймаючою" стороною для директиви `WantedBy=` в сервісі. Коли ви виконуєте `systemctl enable sshd.service` (де вказано `WantedBy=custom.target`), `systemd` автоматично створює символічне посилання на цей сервіс всередині папки `custom.target.wants/`. Таким чином, `Wants=` є способом групування сервісів, які активуються командою `enable`.

#### Крок 2: Модифікація служб

Тепер потрібно "повідомити" службам `varsize` та `sshd`, що вони повинні належати до нашого нового `custom.target`. Це робиться через зміну директиви `WantedBy` в їхніх unit-файлах.

**1. Змініть `varsize.service`:**
Відкрийте файл, який ми створили в попередньому завданні:
```bash
sudo nano /etc/systemd/system/varsize.service
```
Знайдіть рядок `WantedBy=multi-user.target` і замініть його на:
```ini
WantedBy=custom.target
```

**2. Змініть `sshd.service`:**
Редагувати системні unit-файли напряму (`/lib/systemd/system/...`) — погана практика. Правильний спосіб — створити копію файлу в `/etc/systemd/system`, яка матиме вищий пріоритет.

```bash
sudo cp /lib/systemd/system/sshd.service /etc/systemd/system/sshd.service
```
*Примітка: на деяких системах файл може називатися `ssh.service`.*

Тепер відкрийте скопійований файл для редагування:
```bash
sudo nano /etc/systemd/system/sshd.service
```
І так само в секції `[Install]` замініть `WantedBy=multi-user.target` на:
```ini
WantedBy=custom.target
```

#### Крок 3: Застосування змін

`systemd` нічого не знає про наші зміни, доки ми йому про це не скажемо.

**1. Вимкніть служби зі старого таргету:**
Ця команда видалить символічні посилання з каталогу `multi-user.target.wants`.
```bash
sudo systemctl disable varsize.service
sudo systemctl disable sshd.service
```

**2. Перезавантажте конфігурацію `systemd`:**
Це змусить `systemd` перечитати всі unit-файли, включаючи наші нові та змінені.
```bash
sudo systemctl daemon-reload
```

**3. Увімкніть служби для нового таргету:**
Тепер команда `enable` прочитає змінений рядок `WantedBy=custom.target` і створить правильні посилання в каталозі `custom.target.wants`.
```bash
sudo systemctl enable varsize.service
sudo systemctl enable sshd.service
```
Ви можете перевірити, що посилання створені, командою `ls /etc/systemd/system/custom.target.wants/`.

#### Крок 4: Активація та фінальна перевірка

**1. Активуйте новий таргет:**
Перейдіть у режим `custom.target` для поточної сесії.
```bash
sudo systemctl isolate custom.target
```

> #### Пояснення: Чому `isolate`, а не `start`?
>
> *   `systemctl start <юніт>`: Ця команда **запускає** вказаний юніт та його залежності, **але не зупиняє інші активні юніти**. Вона просто додає нові процеси до поточної сесії.
>
> *   `systemctl isolate <таргет>`: Ця команда **перемикає всю систему в новий стан**. Вона активує вказаний таргет, але при цьому **зупиняє всі інші юніти**, які не є частиною нового стану. Це аналог зміни рівнів виконання (runlevels).
>
> **Висновок:** `isolate` використовується для зміни загального режиму роботи системи (таргету), гарантуючи чистий перехід у новий стан. `start` використовується для запуску окремих служб, не змінюючи загального стану системи.

Система повинна працювати як зазвичай, але тепер `varsize` та `sshd` запущені як частина `custom.target`.

**2. Виконайте команду для перевірки:**
```bash
echo $(systemctl list-units --type=target | grep custom | awk '{print $1 $2 $3}') $(systemctl list-dependencies custom.target | head -3 | sed s/[^a-z]//g | sort) | md5sum | cut -c 10-16
```
