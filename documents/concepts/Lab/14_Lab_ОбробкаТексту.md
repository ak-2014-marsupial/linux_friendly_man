### **Завдання 1: Утиліта awk**

> Утилітою awk редагувати вивід наступних команд:

#### **Для `ls -l`**

> **1. Вивести всі рядки**

**Команда:**
```bash
ls -l | awk '{print}'
```
**Пояснення:**
Це найпростіша дія в `awk`. Команда `{print}` (або `{print $0}`) друкує весь поточний рядок. Оскільки це дія за замовчуванням, її можна скоротити до `ls -l | awk 1`.

> **2. Вивести всі рядки довші за 18 символів**

**Команда:**
```bash
ls -l | awk 'length > 18'
```
**Пояснення:**
Вбудована функція `length` (або `length($0)`) повертає довжину поточного рядка. `awk` виводить тільки ті рядки, для яких умова `length > 18` є істинною.

> **3. Вивести рядки тільки для звичайних файлів**

**Команда:**
```bash
ls -l | awk '/^-/'
```
**Пояснення:**
Вивід `ls -l` для звичайних файлів починається з символу `-`. Ця команда використовує регулярний вираз `/^-/` для пошуку та виводу тільки тих рядків, що починаються з `-`.

> **4. Вивести імена файлів довші за 5 символів**

**Команда:**
```bash
sudo ls -lR / | awk '(/^-/ && length($9)>5) {print $9}'
```
**Пояснення:**
Ця команда використовує `sudo ls -lR /` для рекурсивного виведення вмісту кореневого каталогу з детальним форматуванням. `awk` фільтрує ці результати: `(/^-/ && length($9)>5)` перевіряє, чи рядок починається з `-` (що вказує на звичайний файл) І чи довжина дев'ятого поля (`$9`, яке зазвичай є ім'ям файлу) більша за 5 символів. Якщо обидві умови істинні, то друкується дев'яте поле (ім'я файлу).

**Варіант для файлів з пробілами в імені:**

**Команда:**
```bash
sudo ls -lR / | awk '
    # Перевіряємо, чи це звичайний файл (починається з "-")
    /^-/ {
        # Обчислюємо повне ім''я файлу, об''єднуючи поля з 9-го до кінця
        filename = ""
        for (i = 9; i <= NF; i++) {
            if (i > 9) {
                filename = filename " " $i
            } else {
                filename = $i
            }
        }
        
        # Перевіряємо довжину отриманого імені
        if (length(filename) > 5) {
            print filename
        }
    }
'
```
**Пояснення:**
Цей варіант вирішує проблему з іменами файлів, що містять пробіли. Стандартний вивід `ls -l` розглядає кожне слово в імені файлу як окреме поле.
- `/^-/`: Спочатку, як і раніше, відбираються тільки рядки, що стосуються файлів.
- `filename = ""`: Ініціалізується змінна для зберігання повного імені файлу.
- `for (i = 9; i <= NF; i++)`: Запускається цикл, який ітерує з 9-го поля (де починається ім'я файлу) до останнього поля (`NF`).
- `filename = filename " " $i`: У циклі кожне поле додається до змінної `filename` з пробілом, щоб відновити оригінальне ім'я файлу.
- `if (length(filename) > 5)`: Після того, як повне ім'я файлу зібрано, перевіряється його довжина.
- `print filename`: Якщо довжина більша за 5, ім'я файлу виводиться.

> **5. Вивести записи в форматі "Ім'я файлу = $file, розмір = $size"**

**Команда:**
```bash
sudo ls -Rl / | awk '/^-/ {printf( "Ім\'я файлу %s, розмір %s\n", $NF, $5 )}'
```
**Пояснення:**
Ця команда використовує `sudo ls -Rl /` для рекурсивного виведення вмісту кореневого каталогу з детальним форматуванням. `awk` фільтрує ці результати: `(/^-/)` перевіряє, чи рядок починається з `-` (що вказує на звичайний файл). Якщо умова істинна, то використовується функція `printf` для форматованого виводу. `$NF` представляє останнє поле в рядку (зазвичай ім'я файлу), а `$5` - розмір файлу.

---

#### **Для `df`**

> **1. Вивести рядки, що мають відношення до /dev/sda**

**Команда:**
```bash
df -h | awk '$1 ~ /\/dev\/sda/'
```
**Пояснення:**
Оператор `~` виконує перевірку на відповідність регулярному виразу. Ми перевіряємо, чи перше поле (`$1`) містить `/dev/sda`. Слеші в регулярному виразі потрібно екранувати (`\/`).

> **2. Вивести розмір вільного місця на /dev/sda**

**Команда:**
```bash
df | awk '$1 ~ /\/dev\/sda/ {print $4}'
```
**Пояснення:**
Як і в попередньому пункті, ми шукаємо рядок для `/dev/sda`. Після цього ми друкуємо четверте поле (`$4`), яке відповідає за доступний (вільний) простір.

---

#### **Для файлу логів (`/var/log/syslog` або аналогічного)**

> **1. Вивести дані за поточний день**

**Команда:**
```bash
awk -v day=$(date +%d) -v month=$(date +%b) '$1 == month && $2 == day' /var/log/syslog
```
**Пояснення:**
Ми передаємо в `awk` дві змінні: `day` (поточне число) і `month` (назва поточного місяця, напр. `Oct`). `awk` перевіряє, чи перше поле (`$1`) дорівнює місяцю, а друге (`$2`) — дню. Це надійний спосіб відфільтрувати логи за поточну дату.

> **2. Вивести дані старші однієї години**

**Команда:**
```bash
awk -v d="$(date -d '1 hour ago' '+%b %d %H:%M:%S')" '$0 < d' /var/log/syslog
```
**Пояснення:**
Це складне завдання для `awk`. Наведений підхід працюватиме коректно, якщо формат дати в логах збігається з `MMM DD HH:MM:SS` і логи відсортовані за часом. Ми генеруємо часову мітку "годину тому" і порівнюємо її з кожним рядком логу. Рядки, що є лексикографічно меншими за нашу мітку, вважаються старшими.

---

### **Завдання 2: Утиліта sed**

> Утилітою sed виконати наступні дії:

> **1. Замінити всі посилання http на https**

**Команда:**
```bash
sed 's|http://|https://|g'
```
**Пояснення:**
Команда `s/шаблон/заміна/g` виконує пошук і заміну. Тут ми використовуємо `|` як роздільник замість `/`, щоб не екранувати слеші в URL. Прапор `g` (global) означає, що потрібно замінити всі входження в рядку, а не тільки перше.

> **2. Дописати "+" на початок номеру телефону (Привести номери телефонів до єдиного формату)**

**Команда:**
```bash
echo "0501234567 8(050)1234567 80501234567" | sed -E 's/(8|\+38|38|\(8\))?[\s(]*([0-9]{3})[\s)]*([0-9]{3})[\s-]*([0-9]{2})[\s-]*([0-9]{2})/ +38 (\2) \3-\4-\5/g'
```
**Пояснення:**
Ця команда стандартизує різні формати телефонних номерів до вигляду `+38 (XXX) XXX-XX-XX`.
- `(8|\+38|38|\(8\))?` - знаходить і видаляє необов'язковий префікс (`8`, `+38`, `38`).
- `[\s(]*` - знаходить пробіли або дужки після префіксу.
- `([0-9]{3})` - знаходить і захоплює код оператора (група `\2`).
- `([0-9]{3})`, `([0-9]{2})`, `([0-9]{2})` - знаходять і захоплюють решту номера (групи `\3`, `\4`, `\5`).
- У частині заміни `+38 (\2) \3-\4-\5` ми конструюємо новий формат, використовуючи захоплені групи.

> **3. Видалити парні рядки**

**Команда:**
```bash
sed 'n;d'
```
**Пояснення:**
Це портативний спосіб, що працює в більшості версій `sed`. Команда `n` читає наступний рядок (парний), а `d` видаляє його.

> **4. Знайти в журналі утиліти cron дані за поточний день**

**Команда:**
```bash
sed -n "/CRON/ { /$(date '+%b %e')/p }" /var/log/syslog
```
**Пояснення:**
`-n` вимикає автоматичний друк. Спочатку ми шукаємо рядки, що містять `CRON`. Усередині цього блоку `{ ... }` ми шукаємо рядки, що відповідають поточній даті (напр., `Oct 27`), і друкуємо (`p`) їх.

> **5. Видалити "+" на початку номеру телефону**

**Команда:**
```bash
sed -E 's/\+([0-9])/\1/g'
```
**Пояснення:**
Ця команда знаходить символ `+`, за яким іде цифра (яку ми захоплюємо в групу `\1`), і замінює цю комбінацію тільки на саму цифру, фактично видаляючи `+`.

> **6. Якщо номер телефону починається на "+1" і має довжину 12 цифр - видалити плюс і додати два нулі на початок**

**Команда:**
```bash
sed -E 's/^\+1([0-9]{11})$/001\1/'
```
**Пояснення:**
Шаблон `^\+1([0-9]{11})$` знаходить рядки, які точно відповідають формату: `+1` на початку, за яким іде 11 цифр до кінця рядка. `+` і `1` видаляються, а замість них на початок додаються `00`.

> **7. Додати "+" на початок номеру телефону, який має довжину від 10 до 12 цифр, але не починається на 60**

**Команда:**
```bash
sed -E '/^60/! s/^([0-9]{10,12})$/+\1/'
```
**Пояснення:**
Тут використовується адресація. `/^60/!` означає "виконати команду тільки для рядків, що НЕ починаються на 60". Сама команда `s/.../.../` додає `+` на початок рядків, які повністю складаються з 10-12 цифр.

> **8. Зробити так, щоб усі слова починались з великої літери**

**Команда:**
```bash
sed -E 's/\b(\w)/\U\1/g'
```
**Пояснення:**
Це функція GNU `sed`. `\b` знаходить межу слова, `(\w)` знаходить і захоплює перший символ слова. Модифікатор `\U` в рядку заміни перетворює захоплений символ (`\1`) у верхній регістр.

---

### **Завдання 3: Обробка файлу з `sed`**

> Утилітою sed обробити файл наступного виду:
> 
> `user1 {tel: 380671234567, name: test, tel:+380634567853, file=v2}`
> 
> Результат роботи утиліти має формат "name: tel1, tel2", наприклад:
> 
> `test: 380671234567, 380634567853`

**Команда:**
```bash
sed -E 's/.*tel: ?\+?([0-9]{12}), name: ([a-zA-Z]+), tel:\+?([0-9]{12}).*/\2: \1, \3/' file.txt
```

**Пояснення:**
Ця команда використовує розширені регулярні вирази (`-E`) для захоплення та перестановки частин рядка. Вона призначена для обробки рядків, що містять інформацію про користувача, телефонні номери та ім'я, і форматує їх у вигляд "ім'я: телефон1, телефон2".
Регулярний вираз захоплює три групи:
1.  `([0-9]{12})` — перший 12-значний телефонний номер, що йде після `tel: ?\+?`.
2.  `([a-zA-Z]+)` — ім'я, що йде після `name: `.
3.  `([0-9]{12})` — другий 12-значний телефонний номер, що йде після `tel:\+?`.

У частині заміни `\2: \1, \3` ми виводимо захоплені групи в новому порядку: спочатку ім'я (`\2`), потім перший телефонний номер (`\1`), і нарешті другий телефонний номер (`\3`), розділені комою та пробілом.

---

### **Завдання 4: Форматування виводу `ls -l` з `awk`**

> Результат має:
> * містити тільки файли розміром більше N байт і правами на читання для всіх.
> * мати наступний формат:

> `______________________________________________`

> `|             file name          |  size, Kb |`

> `|____________________________________________|`

> `| file 1                         |      13.40 |`

> `______________________________________________`


**Команда (скрипт):**
```bash
sudo ls -l /usr/lib/grub/i386-pc | awk -v N=200 '
   NR==1 {
   print "______________________________________________"
   print "|             file name          |  size, Kb |"
   print "|____________________________________________|"
   next
   }
   $1 ~ /^-r..r..r../ && $5 > N {
   sizeKb = $5 / 1024
   printf "| %-30s |   %7.2f |\n", $9, sizeKb
   }
   END { print "______________________________________________" }
 '
```

**Пояснення:**
1.  `sudo ls -l /usr/lib/grub/i386-pc`: Виконує лістинг файлів у вказаному каталозі з детальним форматуванням. `sudo` потрібен для доступу до системних каталогів.
2.  `-v N=200`: В `awk` передається змінна `N` зі значенням 200, яка буде використовуватись як мінімальний розмір файлу в байтах.
3.  `NR==1`: Ця умова спрацьовує для першого рядка виводу `ls -l` (який зазвичай є "total ...").
    *   `print "..."`: Друкується заголовок таблиці.
    *   `next`: `awk` негайно переходить до наступного рядка, ігноруючи інші правила для поточного рядка.
4.  `$1 ~ /^-r..r..r../ && $5 > N`: Це головна умова фільтрації для всіх інших рядків. Вона перевіряє одночасно дві умови:
    *   `$1 ~ /^-r..r..r../`: Перше поле (права доступу) відповідає регулярному виразу, що означає звичайний файл (`-` на початку) з правами на читання (`r`) для власника, групи та інших.
    *   `$5 > N`: П'яте поле (розмір файлу в байтах) більше за значення змінної `N`.
5.  `{ ... }`: Цей блок виконується, якщо обидві умови вище є істинними.
    *   `sizeKb = $5 / 1024`: Розмір файлу з байтів переводиться в кілобайти.
    *   `printf "| %-30s |   %7.2f |\n", $9, sizeKb`: Друкується форматований рядок таблиці. `%-30s` вирівнює ім'я файлу по лівому краю в полі шириною 30 символів, а `%7.2f` виводить розмір в КБ з двома знаками після коми в полі шириною 7 символів.
6.  `END { print "..." }`: Цей блок виконується один раз після обробки всіх рядків. Він друкує нижню межу таблиці.

---

### **Додаткове завдання: обгортка над `ls`**

> Зробити обгортку над утилітою ls у вигляді awk-скрипту. ... Вивід має містити назву файлу та його розмір в КБ. Таблиця має адаптуватися під розмір вмісту.

**Детальне пояснення:**
Цей `awk`-скрипт є "обгорткою" для команди `ls -l`, яка форматує її вивід у вигляді гарної таблиці з псевдографікою.

**Структура скрипту:**

1.  **`#!/usr/bin/awk -f`**: Це "шебанг" (shebang). Він дозволяє запускати файл `lsw.awk` як самостійний виконуваний файл, автоматично передаючи його інтерпретатору `awk`.

2.  **Блок `BEGIN`**: Цей блок виконується *один раз* до того, як `awk` почне читати рядки з виводу `ls -l`.
    *   `path = ENVIRON["TARGET_PATH"] ? ENVIRON["TARGET_PATH"] : "."`: Скрипт перевіряє, чи встановлена змінна середовища `TARGET_PATH`. Якщо так, він використовує її значення як шлях для відображення. Якщо ні, використовується поточний каталог (`.`)
    *   `name_w = 40; size_w = 15;`: Ініціалізуються змінні, що визначають ширину колонок "File Name" та "Size, KB".
    *   `name_h = " File Name"; size_h = " Size, KB ";`: Заголовки колонок.
    *   `printf "┌...┐\n"`: Малюється верхня рамка таблиці за допомогою Unicode-символів. Цикли `for` використовуються для друку горизонтальних ліній (`─`) потрібної довжини.
    *   `printf "│...│\n"`: Друкується рядок із заголовками колонок. `%-*s` та `%*s` — це специфікатори формату `printf`, що дозволяють вирівнювати текст у полях заданої ширини (`name_w`, `size_w`).
    *   `printf "├...┤\n"`: Малюється лінія-роздільник між заголовком і тілом таблиці.

3.  **Основний блок (`!/^total/`)**: Цей блок виконується для *кожного* рядка, який передається від `ls -l`, за винятком тих, що починаються зі слова "total" (це рядок, який `ls -l` виводить з сумарним розміром блоків).
    *   `count++`: Лічильник файлів збільшується на 1.
    *   `printf "│...│\n"`: Друкується рядок таблиці для поточного файлу.
        *   `$9`: Дев'яте поле з виводу `ls -l` — це ім'я файлу.
        *   `$5/1024`: П'яте поле — розмір у байтах. Ми ділимо його на 1024, щоб отримати кілобайти.
        *   `%-*s` вирівнює ім'я файлу по лівому краю, `*.1f` виводить розмір як число з плаваючою комою (1 знак після коми), вирівняне по правому краю.

4.  **Блок `END`**: Цей блок виконується *один раз* після обробки всіх рядків.
    *   `printf "└...┘\n"`: Малюється нижня рамка таблиці.
    *   `print "Total elements: " count "\n"`: Виводиться загальна кількість оброблених файлів.

**Скрипт (`lsw.awk`):**
```awk
#!/usr/bin/awk -f

BEGIN {
    path = ENVIRON["TARGET_PATH"] ? ENVIRON["TARGET_PATH"] : "."
    print "\nPath: " path "\n"

    name_w = 40; size_w = 15;
    name_h = " File Name"; size_h = " Size, KB ";

    # Верхня межа таблиці
    printf "┌"
    for(i=0; i<name_w; i++) printf "─"
    printf "┬"
    for(i=0; i<size_w; i++) printf "─"
    printf "┐\n"

    # Заголовок
    printf "│%-*s│%*s│\n", name_w, name_h, size_w, size_h

    # Розділювач
    printf "├"
    for(i=0; i<name_w; i++) printf "─"
    printf "┼"
    for(i=0; i<size_w; i++) printf "─"
    printf "┤\n"
}

!/^total/ {
    count++
    printf "│%-*s│%*.1f│\n", name_w, $9, size_w, $5/1024
}

END {
    # Нижня межа таблиці
    printf "└"
    for(i=0; i<name_w; i++) printf "─"
    printf "┴"
    for(i=0; i<size_w; i++) printf "─"
    printf "┘\n"

    print "Total elements: " count "\n"
}
```

**Як використовувати (детальніше):**
1.  **Зберегти скрипт:** Створіть файл з іменем `lsw.awk` і скопіюйте в нього код.
2.  **Зробити виконуваним (опціонально):** Команда `chmod +x lsw.awk` дозволить запускати скрипт просто як `./lsw.awk`.
3.  **Використання:**
    *   `export TARGET_PATH="/var/log"`: Встановлюємо змінну середовища, щоб сказати скрипту, який каталог аналізувати.
    *   `ls -l $TARGET_PATH | awk -f lsw.awk`: Команда `ls -l` виводить список файлів, а її вивід через "пайп" (`|`) передається на вхід нашому `awk`-скрипту для обробки та форматування.
